\documentclass[10pt, conference]{IEEEtran}

% libraries preamble
\usepackage[numbers,sort&compress,square]{natbib}
\usepackage{listings}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{textcomp}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{scrextend}
\usepackage{zi4}

% enable matrix and arrows constructs for tikz
\usetikzlibrary{matrix, arrows}

% configs listings
\renewcommand{\lstlistingname}{Listagem}

\lstset{
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace = true, 
	breaklines = true, 
	captionpos = b, 
	extendedchars = true,
	keywordstyle = \bf,
	keepspaces = true,
	showspaces = false, 
	showstringspaces = false, 
	showtabs = false, 
	tabsize = 2, 
	abovecaptionskip = 1em, 
	belowcaptionskip = 1em, 
	aboveskip = 2em,     
	belowskip = 5pt, 
	xleftmargin = 5pt, 
	xrightmargin = 5pt,
	frame = single,
	framexrightmargin = 3pt,
	framexleftmargin = 3pt,
	framextopmargin = 5pt,
	framexbottommargin = 5pt
}

% configs footnotes
\renewcommand\footnoterule{\kern-3pt \hrule width 2in \kern 2.6pt}

\begin{document}
\bstctlcite{BSTcontrol}

\title { 
	Teoria das Categorias \\
	Mónades e Flechas \\
	em Java 
}

\author{

	\IEEEauthorblockN{ Mozart L. Siqueira¹, Pablo M. Parada² }
	\IEEEauthorblockA{
		Ciência da Computação \\
		Centro Universitário La Salle - Unilasalle \\
		E-mail: mozarts@unilasalle.edu.br¹, pablo.paradabol@gmail.com²
	}
}
					  
\maketitle

\thispagestyle{plain}
\pagestyle{plain}

\begin{abstract}

\textcolor{red}{<escrever>}

\end{abstract}

\begin{IEEEkeywords}

\textcolor{red}{<escrever>}

\end{IEEEkeywords}

\section{INTRODUÇÃO}
\label{sec:intro}

<escrever>

\section{PARADIGMA FUNCIONAL}
\label{sec:func-para}

Influenciado principalmente pelo desenvolvimento do lambda calculus~\cite{hudak1989conception}, compondo o grupo da programação declarativa, o paradigma funcional utiliza-se da ideia de expressar computações através de funções combinadas em expressões. Neste, funções determinam o que deverá ser computado, ao invés de como sera computado~\cite{louden2011programming}. Programas são construídos através da composição, tal que funções triviais (building blocks) são combinadas dando origem a novas funções que descrevem computações mais complexas.

Building blocks não devem fazer uso de variáveis que dependam de estado, isso significa que a computação deve ser pura e sem efeitos colaterais (side-effects). Também destaca-se o princípio de imutabilidade, onde o valor de uma variável é determinado em sua criação, não permitindo novas atribuições posteriormente. Ao expressar um programa em uma linguagem funcional obtém-se uma maneira concisa de solucionar problemas, sendo que este constitui-se de operações e objetos atômicos e regras gerais para sua composição~\cite{michaelson2011introduction}.

Tais propriedades são apreciadas nos tempos atuais, visto que a Lei de Moore nos fornece cada vez mais núcleos, não necessariamente núcleos mais rápidos~\cite{jsr335}. Em programas não-determinísticos, múltiplas threads podem alterar os dados representados por objetos imutáveis sem ocasionar os diversos problemas já conhecidos como dead locks e race conditions. Além do thread safety oferecido pela propriedade de imutabilidade, há também o conceito de funções transparentes referencialmente, ou seja, funções que não utilizam variáveis de estado. Em ambientes distribuídos onde a execução é subdivida em diferentes threads, a transparência referencial garante sempre o mesmo retorno, dados os mesmos argumentos.

O paradigma funcional expressa programas através de composições mantendo a imutabilidade e a transparência referencial, portanto apresenta caraterísticas importantes para os tempos atuais. A complexidade intrínseca à ambientes distribuídos é reduzida. Programas completos são vistos como apenas uma aplicação de função.

\section{JAVA LAMBDA EXPRESSIONS}

Na última década muitos dos problemas encontrados -- como enviar não só dados, mas também comandos através de redes -- já foram solucionados em linguagens que suportam o paradigma funcional~\cite{fischer2015java}. Assim, linguagens multi-paradigma têm adicionado suporte à estas mesmas estruturas, aumentando sua flexibilidade e ganho para com os desenvolvedores. O suporte a lambda expressions em Java não tem como objetivo apenas substituir Anonymous Inner Classes, mas também ser capaz de trazer os benefícios deste paradigma ao ponto de incrementar o ecossistema da linguagem.

\subsection{Lambda Expressions e Anonymous Inner Classes}
Ao fornecer suporte a funções de primeira classe, também chamadas de lambda expressions ou closures\footnote{Lambda expressions ou closures são funções que não exigem vínculos de classe, como exemplo podendo ser atribuída a uma variável. Com esta caraterística, uma função atua como dado, ou seja, pode ser passada como argumento para outras funções.}, a linguagem Java habilita a substituição de annonymous inner classes (AIC) de forma transparente. Conforme a Listagem~\ref{lst:array-aic-sort}, em Java a ordenação de inteiros pode ser implementada a partir de uma AIC em conjunto do método $sort$ da classe $Arrays$.

\begin{lstlisting}[caption={Sort - Anonymous Inner Class}, label={lst:array-aic-sort}]
Integer[] integers = new Integer[]{5, 4, 3, 2, 1};

Arrays.sort(integers, new Comparator<Integer>() {
    public int compare(Integer a, Integer b) {
        return a.compareTo(b);
    }
});
\end{lstlisting}

Neste trecho de código o método $sort$ recebe como primeiro argumento um array de inteiros (já declarado na variável $integers$) e como segundo qualquer instância que satisfaça o contrato de $Comparator$. Assim, para satisfazer o segundo argumento, instância-se uma AIC através da palavra reservada $new$ que implementa o método $compare$ declarado no contrato.

Entretanto, com closures o mesmo método $sort$ pode ter seus argumentos simplificados. Conforme demonstrado na Listagem~\ref{lst:array-lambda-sort}, ao invés de instanciar uma AIC, uma lambda expression é passada como segundo argumento, removendo a necessidade de instanciação de uma classe e a implementação de um contrato imposto por $Comparator$.

\begin{lstlisting}[caption={Sort - Lambda Expression}, label={lst:array-lambda-sort}]
Arrays.sort(integers, (a, b) -> a.compareTo(b));
\end{lstlisting}

De fato, apesar de expressarem o mesmo comportamento a nível de código, ambas funcionalidades possuem diferentes implementações sob a Máquina Virtual Java (JVM). AIC são compiladas, ou seja, geram novos arquivos contendo declarações de classes. Além do mais, ao utilizar a palavra reservada $this$ referencia-se a própria instância anônima. Como representam instâncias de uma classe, estas devem ser carregadas pelo classloader e seus construtores invocados pela máquina virtual. Ambas etapas consomem memória, tanto heap~\cite{hunt2011java} para alocação de objetos quanto permgem\footnote{Área de memória limitada separada da heap chamada Permanent Generation que possui a função de armazenar objetos de geração permanente como metadados, classes e métodos.}.

Diferentemente de AIC, lambdas postergam a estratégia de compilação para em tempo de execução, utilizando a instrução $invokedynamic$~\cite{goetz2012translation}. Funções são traduzidas para métodos estáticos vinculados ao arquivo da classe correspondente a sua declaração, eliminando o consumo de memória. Agora, ao referir-se a $this$, a classe que delimita a lambda expression é acessada, ao contrário de AIC que acessa sua própria instância.

Dessa forma, o suporte a lambda expressions traz benefícios para os usuários da linguagem. Tal funcionalidade está além de uma mera substituição, pois acrescenta um novo paradigma no ecossistema Java.

\section{TEORIA DAS CATEGORIAS E SUAS ESTRUTURAS}
A Teoria das Categorias (TC) foi inventada no início dos anos 1940 por Samuel Eilenberg e Sunders Mac Lane~\cite{eilenbergmaclane1945naturalequivalences} como uma ponte entre os diferentes campos da topologia e álgebra~\cite{spivak2014cts}. Afim de demonstrar as relações entre estruturas e sistemas matemáticos~\cite{maclane1971mat}, a TC estabelece uma linguagem formal capaz de encontrar aplicabilidade em várias áreas da ciência. Por volta dos anos 1980, computação e TC passaram a ser consideradas áreas correlatas de estudo~\cite{carlos2006caracteristicas}.

Aplicações do modelo categorial ocorrem na composição de funções encorajada pelo paradigma funcional. Além do mais, em linguagens de programação, o estudo dos tipos pode ser representado através de categorias. Muitos modelos computacionais que fazem uso de estruturas de dados como grafos podem ser generalizados para categorias de grafos. Portanto, tais aplicações demonstram a capacidade de abstração e a importância da TC para a computação.

\begin{figure}[!h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
    	\matrix (m) [
        	    matrix of math nodes,
            	row sep=3em,
	            column sep=5em,
				text height=2ex, text depth=0.5ex
            	] {
			A & B \\
			  & C \\
        };
    	\path[->]
        	(m-1-1) edge node[above] {$f$} (m-1-2)
			(m-1-2) edge node[right] {$g$} (m-2-2)
			(m-1-1) edge node[left = 0.9cm, below = 0.001cm] {$h =$ $g \circ f$} (m-2-2);
	\end{tikzpicture}
\caption{Funções entre coleções de objetos}
\label{fig:f-g-composition}
\end{figure}

Tal como a Teoria dos Grupos\footnote{Teoria que estuda as estruturas algébricas de grupos. Um grupo é formado por um conjunto de elementos finito ou infinito associado a uma operação binária, como por exemplo a adição ou multiplicação.} abstrai a ideia do sistema de permutações como simetrias de um objeto geométrico, a TC manifesta-se como um sistema de funções entre conjuntos de objetos~\cite{awodey2010category}. Esta abstração pode ser vista a partir da Figura~\ref{fig:f-g-composition}, onde os conjuntos de objetos são representado por $A$, $B$ e $C$. Nesta mesma estrutura, $f$ e $g$ denotam os morfismos entre os diferentes conjuntos de objetos, tal que ${f: A \rightarrow B}$ e ${g: B \rightarrow C}$. Por fim, $h$ expressa a ideia de composição, sendo produto da união dos morfismos $f$ e $g$. 

A TC nasceu como uma ferramenta matemática, com propósito de estudar a relação objetos e morfismos. Contudo, tal conceito tornou-se uma ferramenta utilizada por diversas áreas da ciência. Na computação, diversos problemas são abstraídos através de estruturas da TC, pois ajudam na sua resolução.

\subsection{Categoria -- Objetos e Morfismos}
\label{subsec:sub-cat}
Uma categoria consiste em uma coleção de coisas, todas relacionadas de algum modo. As coisas são nomeadas de objetos e as relações de morfismos \cite{spivak2014cts}.\\

\textbf{Definição}~\cite{spivak2014cts, maclane1971mat}: define-se a categoria $C$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item uma coleção ${Ob(C)}$, contendo os objetos de $C$;
	\item para cada par ${a, b \in Ob(C)}$, um conjunto ${Hom_C(a, b)}$ chamado de morfismos de $a$ para $b$;
	\item para cada objeto ${a \in Ob(C)}$, um morfismo de \textit{identidade} em $a$ denotado por ${id_a \in Hom_C(x, a)}$;
	\item para cada três objetos ${a, b, c \in Ob(C)}$, uma função de composição $\circ: Hom_C(b, c) \times Hom_C(a, b) \rightarrow Hom_C(a, c)$;
\end{enumerate}

Dado os objetos $a, b \in Ob(C)$, denota-se o morfismo $f \in Hom_C(a, b)$ por $f: a \rightarrow b$; onde $a$ é o domínio e $b$ o contradomínio.\\	

Estas operações em $C$ devem satisfazer os seguintes axiomas:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a, b \in Ob(C)$ e todo morfismo $f: a \rightarrow b$, tem-se $id_a \circ f = f = id_b \circ f$;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c, d \in Ob(C)$ e os morfismos $f: a \rightarrow b$, $g: b \rightarrow c$ e $h: c \rightarrow d$. Então $(h \circ g) \circ f = h \circ (g \circ f)$.
\end{enumerate}

Ambos axiomas podem ser representados pelos diagramas comutativos das Figura~\ref{fig:comut-ident} e Figura~\ref{fig:comut-assoc}.

\begin{figure}[h]
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						]{
							a & a \\
							b & b \\
						};

					\path[->]
						(m-1-1) edge node[above] {$id_a$} (m-1-2)
						(m-1-1) edge node[left] {$f$} (m-2-1)
						(m-1-2) edge node[above] {$f$} (m-2-1)
						(m-1-2) edge node[right]  {$f$} (m-2-2)
						(m-2-1) edge node[above] {$id_b$} (m-2-2);
			\end{tikzpicture}
			\caption{Identidade}
			\label{fig:comut-ident}
	\end{minipage}
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						] {
							a & b \\
							c & d \\
						};
					\path[->]
						(m-1-1) edge node[above] {$f$} (m-1-2)
						(m-1-1) edge node[left] {$g \circ f$} (m-2-1)
						(m-1-2) edge node[above] {$g$} (m-2-1)
						(m-1-2) edge node[right]  {$h \circ g$} (m-2-2)
						(m-2-1) edge node[above] {$h$} (m-2-2);
			\end{tikzpicture}
			\caption{Associatividade}
			\label{fig:comut-assoc}
	\end{minipage}
\end{figure}

\subsection{Funtor -- Morfismos entre Categorias}
\label{subsec:funtor}
Um funtor é um mapeamento entre duas categorias de tal modo que o domínio, contradomínio, objetos e morfismos são preservados~\cite{awodey2010category}.\\

\textbf{Definição}~\cite{maclane1971mat, spivak2014cts}: para as categorias $C$ e $D$, um funtor $F:C \rightarrow D$ com domínio $C$ e contradomínio $D$ consiste em duas funções relacionadas. São elas:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item a função de objeto $F$ que atribui cada objeto $a \in Ob(C)$ para um objeto $F(a) \in Ob(D)$;
	\item e a função de flecha (também chamada $F$) que atribui cada morfismo $f: a \rightarrow b \in Hom_C(a, b)$ para um morfismo $F(f):F(a) \rightarrow F(b) \in Hom_D(a, b)$.
\end{enumerate}

\bigskip

Tal que os seguintes axiomas são satisfeitos:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a \in Ob(C)$ existe um morfismo $F(id_a) = id_{F_{(a)}}$ que preserva a identidade;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c \in Ob(C)$ e os morfismos $f: a \rightarrow b$ e $g: b \rightarrow c$. Então $F(g \circ  f) = F(g) \circ F(f)$.
\end{enumerate}

\bigskip

Estas funções capazes de preservar as características das categorias $C$ e $D$ também podem ser ilustradas a partir da Figura~\ref{fig:func-f}.

\begin{figure}[h]
			\begin{tikzpicture}[->, >= stealth', shorten >= 1pt, auto]
				\node [above = 1cm, right = 5cm, scale=.91] (D) {$D)$};
				\node [above = 1cm, left = 1.5cm, scale=.91] (C) {$C)$};
				\node [left = 1cm, scale=.9] (a) {a};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
  				\node [right of = b, below = .4cm, node distance = 1.4cm, scale=1.1] (F) {$F \Rightarrow$};
 				\node [below of = b, node distance = 1.5cm, scale=.9] (c) {c};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
				\node [right of = b, node distance = 3.5cm, scale=.9] (fa) {F(a)};
  				\node [right of = fa, node distance = 1.5cm, scale=.9] (fb) {F(b)};
  				\node [below of = fb, node distance = 1.5cm, scale=.9] (fc) {F(c)};
				
				\path[->, every loop/.style={looseness=10}]

					(a) edge [in = 190, out = 120, loop, left] node[scale=.75] {$id_a$} (a);
					
				\path[->, every loop/.style={looseness=10}]
				
					(fa) edge [in = 190, out = 140, loop, left] node[scale=.75] {$F(id_a)$} (fa);
				
				\draw[->, shorten >= 1pt] (a)-- node[above] {$f$} (b);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				\draw[->, shorten >= 1pt] (a)-- node[left = 0.5cm, below = 0.001cm] {$g \circ f$} (c);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fb)-- node[right] {$g$} (fc);
				\draw[->, shorten >= 1pt] (fa)-- node[left = 0.7cm, below = 0.001cm] {$F(g \circ f)$} (fc);

			\end{tikzpicture}
			\caption{Funtor $F$}
			\label{fig:func-f}
\end{figure}

\subsection{Mónade -- Endofuntor e Transformações Naturais}
\label{subsec:monad}
Podendo ser visto como um padrão estrutural que ocorre diversos ramos da matemática~\cite{spivak2014cts}, a construção fundamental mónade (também chamada de tripla) estrutura-se a partir de um endofuntor\footnote{Um funtor que mapeia uma categoria para ela mesma.} e das transformações naturais\footnote{Mapeamento entre dois funtores que possuem o mesmo domínio e contradomínio, tal que satisfaça a condição de naturalidade.} de identidade e multiplicação.\\

\textbf{Definição}~\cite{maclane1971mat, awodey2010category}: dada a mónade $T = (T, \eta, \mu)$ em uma categoria $C$ consiste em:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item um endofuntor $T$, tal que $T: C \rightarrow C$;
	\item nas transformações naturais:
	\begin{enumerate}[label={}]
		\item (\textit{Identidade}) $\eta: id_C \rightarrow T$;
       	\item (\textit{Multiplicação}) $\mu: T^2 \rightarrow T$, onde $T^2 = T \circ T$.
	\end{enumerate}
\end{enumerate}

Fazendo com que os diagramas da Figura~\ref{fig:mon-comut-ident} e Figura~\ref{fig:mon-comut-assoc} comutem, respeitando os axiomas de identidade (esquerda e direita) e associatividade.

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T & T^2 & T \\
					  &  T  &   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$\eta_T$} (m-1-2)
				(m-1-2) edge node[above] {$T_\eta$} (m-1-3)
				(m-1-1) edge node[left = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-3) edge node[right = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Identidade à Esquerda e à Direita}
	\label{fig:mon-comut-ident}
\end{figure}

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T^3 & T^2 \\
					T^2 & T   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$T_\mu$} (m-1-2)
				(m-1-1) edge node[left] {$\mu_T$} (m-2-1)
				(m-2-1) edge node[below] {$\mu$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Associatividade}
	\label{fig:mon-comut-assoc}
\end{figure}

\subsection{Flechas -- Categoria de Kleisli}
\label{subsec:arrow}
A partir de uma tripla obtemos a Categoria de Kleisli (CK), capaz de representar a mesma estrutura monádica através de uma sintaxe diferente~\cite{hill1994introduction}. Mantendo definições similares as já apresentadas em~\ref{subsec:sub-cat}, a CK destaca-se por abstrair a estrutura de objetos e morfismos sendo capaz compor o endofuntor subjacente.\\

\textbf{Definição}~\cite{maclane1971mat, pedicchio2004categorical, hill1994introduction}: dada a tripla $(T, \eta, \mu)$ sob a categoria $C$, então define-se $C_T$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item cada objeto $a \in Ob(C)$, um novo objeto $a_T$;
	\item cada morfismo $f: a \rightarrow T_b$, um novo morfismo ${f^*: a_T \rightarrow b_T}$.
\end{enumerate}

\bigskip

Dado os morfismos ${f^*: a_T \rightarrow b_T}$, $g^*: b_T \rightarrow c_T$ e ${h: c \rightarrow d_T}$ e o operador de extensão $-^*$, então:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (\textit{Composição}) $g^* \circ f^* = (\mu_c \circ T(g) \circ f)^*$.
\end{enumerate}

\bigskip

Similar as outras estruturas desta seção, $C_T$ deve obedecer as seguintes leis:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (\textit{Identidade à Esquerda}) $f^* \circ \eta_a = f$;
	\item (\textit{Identidade à Direita}) $\eta^*_a \circ h = id_{T(a)} \circ h$;
	\item (\textit{Associatividade}) $(g^* \circ (f^* \circ h)) = (g^* \circ f)^* \circ h$.
\end{enumerate}

\bigskip

\section{APLICAÇÃO EM HASKELL}

As funções do paradigma funcional podem ser vistas como morfismos na categoria dos tipos. Percebendo estas relações, Wadler~\cite{peyton1993imperative, wadler1995monads, wadler1992comprehending, wadler1992essence} utilizou o conceito de mónade para estruturar programas puramente funcionais em Haskell. Assim, o primeiro problema pertencente ao conjunto Awkward Squad foi solucionado~\cite{jones2001tacklingthe}.

A introdução da mónade para E/S (entrada e saída) padronizou a maneira de executar  estas ações e encapsular seus efeitos colaterais. Assim, outras mónades foram adicionadas à linguagem, estendendo as bibliotecas padrões para fornecer suporte a exceções, nulidade, concorrência, etc. Logo, mónades trouxeram utilidade para a linguagem, pois confrontaram o Awkward Squad~\cite{jones2001tacklingthe}.

Com a rápida adoção de mónades para a solução de problemas envolvendo E/S, constatou-se que outros conceitos da TC também poderiam ser aproveitados. Qualquer estrutura recursiva (listas, mapas, árvores, grafos) que possa ser iterada é representada por um funtor. A categoria de Haskell, chamada Hask, preocupa-se em tratar tipos como objetos e funções como morfismos, fornecendo funções de composição e identidade.

Type classes definem comportamentos genéricos que podem ser implementados por um conjunto variado de tipos. Esta funcionalidade tornou a implementação das estruturas previamente mencionadas disponíveis para qualquer tipo de dado, dependendo apenas da implementação de suas instancias~\cite{o2008real}.

\begin{figure}[h]
\centering
	\scalebox{.85}{
		\input{images/typeclassopedia.tex}
	}
	\bigskip
	\caption[Typeclass Hierarchy]{Hierarquia de type classes\footref{fnt:typeclassopedia}}
	\label{fig:typeclassopedia}
\end{figure}

\addtocounter{footnote}{1}
\footnotetext{Fonte:~\url{https://wiki.haskell.org/Typeclassopedia}. Acessado em 17/09/2015.\label{fnt:typeclassopedia}}
	
Conforme a Typeclassopedia~\cite{web2015typeclassopedia}, a Figura~\ref{fig:typeclassopedia} demonstra as relações entre as type classes, identificadas por flechas tracejadas e pontilhadas:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item (\textit{Tracejadas}) Determinam relações de é-um, ou seja, se existe uma flecha de $A$ para $B$, então todo $B$ é um $A$;
	\item (\textit{Pontilhadas}) Indicam algum tipo de relação, como por exemplo a equivalência entre $Monoid$ e $MonadPlus$.
\end{enumerate}

A implementação de uma type class pode ser visualizada na Listagem~\ref{lst:type-class-eq}, onde a primeira declaração incorpora uma nova classe com nome $Eq$, uma variável de tipo $a$ e um comportamento explicitado pela função $equals$. 

\begin{lstlisting}[caption={Type class Eq\protect\footref{fnt:type-class-eq}}, label={lst:type-class-eq}]
class Eq a where
	equals :: a -> a -> Bool
\end{lstlisting}

Na Listagem~\ref{lst:instance-eq}, instancia-se $Eq$ para os tipos $Int$ e $Char$. A primeira instancia declara que $Int$ pertence a $Eq$, e que a implementação de igualdade de inteiros é dada por $primEqInt$. Similarmente, $Char$ pertence $Eq$ e fornece a implementação de igualdade por $primEqChar$. Logo, como $a$ é um parâmetro de tipo, as assinaturas de $primEqInt$ e $primEqChar$ são tipadas ${Int \rightarrow Int \rightarrow Bool}$ e ${Char \rightarrow Char \rightarrow Bool}$ consecutivamente~\cite{hall1996type}.

\begin{lstlisting}[caption={Instancias Eq\protect\footref{fnt:type-class-eq}}, label={lst:instance-eq}]
instance Eq Int where
	equals = primEqInt
	
instance Eq Char where
	equals = primEqChar
\end{lstlisting}
	
\addtocounter{footnote}{1}
\footnotetext{Fonte: C. V. Hall \textit{et al.}, Type Classes in Haskell, p. 3, 1996.\label{fnt:type-class-eq}}

Com a instancia de $Eq \; Int$ é possível comparar dois inteiros tal que ${equals({1 + 1}, 2)}$ retorna $True$; ou ${equals({1 + 1}, 0)}$ retorna $False$. De maneira similar, com $Eq \; Char$ é possível comparar dois caracteres, onde ${equals('a', {'a'})}$ retorna $True$; ou ${equals('a', {'b'})}$ retorna $False$.

\subsection{Monad}

Para a programação funcional, mónades oferecem um contexto computacional que encapsula efeitos colaterais. Além disso, tal contexto monádico permite o encadeamento de funções que operam sob um determinado tipo. Em Haskell, esta abstração é expressa através da type class $Monad$.

\begin{lstlisting}[caption={Type class Monad\protect\footref{fnt:haskell-language-report}}, label={lst:type-class-monad}]
class Monad m where
	(>>=)  :: m a -> (a -> m b) -> m b
	(>>)   :: (>>) m a -> m b -> m b
	return :: a -> m a
\end{lstlisting}

Conforme a Listagem~\ref{lst:type-class-monad}, a type class $Monad$ consiste em um tipo construtor $m$ e as operações $>>=$, $>>$ e $return$. A operação $>>$ existe apenas como um facilitador para a composição de funções no contexto $m$. $>>=$ e $return$ são equivalentes as transformações naturais de multiplicação e identidade.

A operação $return$ encapsula o tipo $a$ no contexto monádico $m\;a$ e retorna este como resultado. A próxima é bind, declarada simbolicamente por $>>=$, que habilita o encadeamento de funções. Bind aplica a função $a \rightarrow m\;b$ no contexto monádico $m\;a$, retornando uma nova instancia de $Monad$ do tipo $m\;b$.

Todas instâncias de $Monad$ devem seguir as leis monádicas de associatividade e identidade. Estes axiomas são demonstrados na Listagem~\ref{lst:monad-laws}.

\begin{lstlisting}[caption={Leis para $Monad$\protect\footref{fnt:haskell-language-report}}, label={lst:monad-laws}]
return a >>= k = k a
m >>= return = m
m >>= (\x -> k x >>= h) = (m >>= k) >>= h
\end{lstlisting}

A possibilidade de encadear funções com $>>=$ é tão importante que diversas linguagens funcionais oferecem suporte sintático para mónades. Em Haskell, esta sintaxe especial é chamada de \textbf{do notation}~\cite{marlow2010haskell}.

\begin{lstlisting}[caption={Encadeando Funções com Bind e Then\protect\footref{fnt:haskell-language-report}}, label={lst:func-chaining}]
putStr "x: " >>
getLine >>= \l -> 
return (words l)
\end{lstlisting}

Na Listagem~\ref{lst:func-chaining} as funções $putStr$ e $getLine$ são encadeadas pelos operadores $>>$ e $>>=$. Estas mesmas funções podem ser encadeadas utilizando a utilizando o suporte sintático de \textbf{do notation}, conforme a Listagem~\ref{lst:do-notation}.

\begin{lstlisting}[caption={Encadeando Funções com Do Notation\protect\footref{fnt:haskell-language-report}}, label={lst:do-notation}]
do 
	putStr "x: "
	l <- getLine
	return (words l)
\end{lstlisting}

Com esta notação, um código pertencente ao paradigma funcional é escrito de forma imperativa, ou seja, a computação é declarada passo a passo. Assim, obtém-se uma sintaxe simplificada para expressar efeitos colaterais em linguagens puramente funcionais como Haskell.

\addtocounter{footnote}{1}
\footnotetext{Fonte: S. Marlow \textit{et al.}, Haskell 2010 Language Report, p. 25--81, 2010.\label{fnt:haskell-language-report}}

\subsection{Arrow}

\addtocounter{footnote}{1}
\footnotetext{Fonte: A. Courtney e E. Conal, Genuinely functional user interfaces, p. 5, 2001.\label{fnt:arrow-user-interface}}

\addtocounter{footnote}{1}
\footnotetext{Fonte: \url{http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html}. Acessado em: 26/09/2015.\label{fnt:prelude}}

Conforme o exemplo de programação tácita~\footnote{Um paradigma de programação no qual as funções não identificam seus argumentos, em vez disso são construídas a partir de funções combinatórias que manipulam os argumentos.} da Listagem~\ref{lst:func-count}, Hughes~\cite{hughes2005programming} constrói uma função que conta o numero de ocorrências de uma palavra em um $String$.

\begin{lstlisting}[caption={Função $count$\protect\footref{fnt:prog-with-arrows}}, label={lst:func-count}]
count w = length . filter (==w) . words
\end{lstlisting}

A função $count$ é implementada pela união de $length$, $filter$, $==$ e $words$. Por último mas não menos importante, a função de composição $(.)$ atua na implementação de $count$ como um operador de ligação entre as funções menores. Entretanto, funções com efeitos colaterais não são compostas tão facilmente. 
Conforme a Listagem~\ref{lst:func-io}, $readFile$ retorna um $String$ encapsulado pela mónade $IO$. Em contrapartida, $count$ espera um $String$ como argumento, não um tipo construtor $m$.

\begin{lstlisting}[caption={Funções de E/S\protect\footref{fnt:prog-with-arrows}\protect\footref{fnt:prelude}}, label={lst:func-io}]
readFile :: FilePath -> IO String
\end{lstlisting}

Não há como por exemplo utilizar $(.)$ para unir $readFile$ e $count$, ou seja, não é possível ler um arquivo do disco e contar a ocorrência de uma determinada palavra. Entretanto, a união destas é desejável. Sendo assim, para permitir a composição destes tipos de funções, Hughes introduziu a type class $Arrow$. Na Listagem~\ref{lst:tc-arrow}, $Arrow$ denota uma computação pelos tipos $b$, $c$ e $d$, um tipo construtor $a$ e as operações $arr$ e $>>>$. 

\begin{lstlisting}[caption={Type class $Arrow$\protect\footref{fnt:arrow-user-interface}}, label={lst:tc-arrow}]
class Arrow a where
	arr   :: (b -> c) -> a b c
	(>>>) :: a b c -> a c d -> a b d
\end{lstlisting}

Destas, a mais comum é $arr$, declarada com a assinatura ${(b \rightarrow c) \rightarrow a\;b\;c}$. Dada qualquer função com entrada $b$ e saída $c$, $arr\;f$ constrói uma instância de $Arrow$ a partir de $f$~\cite{courtney2001genuinely}. 

A segunda operação é definida simbolicamente por $(>>>)$ com assinatura ${a\;b\;c \rightarrow a\;c\;d \rightarrow a\;b\;d}$. Recebe como argumento uma instância definida por ${a\;c\;d}$ e retorna $a\;b\;d$. Logo, $(>>>)$ aplica sequencialmente as funções passadas para $arr$, gerando uma computação de entrada $b$ e saída $d$ encapsuladas em uma instância de $Arrow$.

Tem-se na Listagem~\ref{lst:func-comp-arrow} uma instancia de $Arrow$ que fornece a composição de funções ordinárias. Nesta, $arr$ é implementada pela função de identidade $id$, disponível no pacote $Prelude$. Na operação de composição $(>>>)$, utiliza-se $(.)$ e $flip$~\cite{hughes2005programming}. Assim, define-se o tipo ${Arrow\;(\rightarrow)}$,  instancia de $Arrow$ para funções ordinárias. Sua assinatura é dada por $a \rightarrow b$, sendo $a$ e $b$ tipos quaisquer.

\begin{lstlisting}[caption={Arrow - Composição de Funções\protect\footref{fnt:prog-with-arrows}}, label={lst:func-comp-arrow}]
instance Arrow (->) where
	arr   = id
	(>>>) = flip (.)
\end{lstlisting} 

Além disso, a definição do tipo $Kleisli$ para $Arrow$ na Listagem~\ref{lst:kleisli-type} e~\ref{lst:kleisli-arrow} provê a composição de mónades. Os tipos de entrada e saída são definidos explicitamente em $Kleisli$, diferentemente de $Monad$. Portanto, ${Arrow\;(Kleisli\;m)}$ generaliza $Monad$~\cite{hughes2005programming}.

\begin{lstlisting}[caption={Definição do tipo $Kleisli$\protect\footref{fnt:prog-with-arrows}}, label={lst:kleisli-type}]
newtype Kleisli m a b = Kleisli { 
	runKleisli :: a -> m b 
}
\end{lstlisting}


\begin{lstlisting}[caption={Instância para $Monad$\protect\footref{fnt:prog-with-arrows}}, label={lst:kleisli-arrow}]
instance Monad m => Arrow (Kleisli m) where

	...
	
	first (Kleisli f) = Kleisli (\(a,c) -> 
									do b <- f a
									   return (b,c))
\end{lstlisting}

Apesar de possuir nove axiomas, na Listagem~\ref{lst:arrow-law} estão listados apenas os necessários para as operações de composição e identidade~\cite{lindley2011idioms}.

\begin{lstlisting}[caption={Leis para $Arrow$\protect\footref{fnt:arrows-and-idioms}}, label={lst:arrow-law}]
arr id >>> f = f
f >>> arr id = f
(f >>> g) >>> h = f >>> (g >>> h)
arr (g . f) = arr f >>> arr g

...

\end{lstlisting}

\section{Aplicação em Java}

A linguagem Java originou-se a partir de um projeto de pesquisa, tendo como
objetivo de desenvolver uma plataforma capaz de operar em tempo real. Em sua criação, decisões arquiteturais e de design foram embasadas em linguagens como SmallTalk, Eifell, Objective C e Cedar/Mesa~\cite{gosling1995java}. Para ser considerada uma linguagem orientada a objetos, Java suporta encapsulamento, polimorfismo e herança desde sua elaboração.

Desde sua quinta versão, tendo como base o trabalho de Bracha \textit{et al.}~\cite{bracha2004generics, bracha1998making}, Java conta com tipos genéricos. A abstração de tipos nos permite utilizar tipos parametrizáveis, generalizando implementações de interfaces, classes e métodos. Com isto o compilador é capaz de checar os tipos em tempo de compilação, evitando erros de conversão e em tempo de execução.

\addtocounter{footnote}{1}
\footnotetext{Fonte: J. Hughes, Programming with Arrows, p. 73--81, 2005.\label{fnt:prog-with-arrows}}

\addtocounter{footnote}{1}
\footnotetext{Fonte: S. Lindley e P. Wadler, Idioms are oblivious, arrows are meticulous, monads are promiscuous, p. 97--98, 2011.\label{fnt:arrows-and-idioms}}

Recentemente obteve-se o suporte a funções anônimas. Estas foram adicionadas a partir do Lambda Project~\cite{jsr335}, na versão 8 da JDK. De extrema importância, Lambda Expressions acrescentam  novas características compatíveis com as já existentes em linguagens funcionais. Logo, contando com as funcionalidades já citadas e as recém adicionadas na plataforma, Java é capaz de fornecer suporte a mónades e flechas.

\subsection{Problema dos Tipos Construtores}

Construtores de classe constroem objetos, respectivamente, tipos construtores constroem tipos. Tipos construtores possuem aridade, ou seja, recebem tipos como argumento~\cite{pierce2002types}. Se um tipo construtor não receber argumentos, este é chamado de tipo construtor nulário. Um tipo qualquer $A$ origina-se a partir de um construtor nulário, assim como um tipo $C(A)$ é aplicado para construtores de aridade $n$.

Tipos genéricos são equivalentes a construtores unários, incapazes de representar tipos construtores com aridade $n$. Tendo como exemplo o mesmo tipo $C(A)$ anterior, este poderia ser expresso por genéricos se $C$ fosse estaticamente definido. Portanto, para qualquer $C$ definido estaticamente como $List$, $Set$, $Queue$, $Map$, e assim em diante, é possível parametrizar $A$ com genéricos.

Entretanto, para a construção da interface monádica é necessário expressar um tipo construtor de aridade $n$. A declaração de um tipo $Monad(M(A))$ utilizando tipos genéricos é inválida, ocasiona um erro em tempo de compilação. Logo, a declaração de interface abaixo não pode ser expressa na linguagem.

\begin{lstlisting}[caption={Interface Monad inválida}, label={lst:invalid-generic-monad}]
public interface Monad<M<A>> {}
\end{lstlisting}

Afim de solucionar esta inconsistência, na Listagem~\ref{lst:kind-interface} propõe-se o tipo $Kind(A, K)$. Sendo capaz de simular tipos construtores, este possui os parâmetros de tipo genérico $A$ e $K$.

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item ($A$) este primeiro parâmetro genérico é equivalente ao valor encapsulado $A$ na declaração ${Monad(M(A))}$.
	\item ($K$) determina uma restrição de herança, na qual $K$ herda $Kind$ e parametriza este com um tipo curinga e o próprio $K$ que representa $Kind$.
\end{enumerate}

\begin{lstlisting}[caption={Interface Kind}, label={lst:kind-interface}]
public interface Kind<A, K extends Kind<?, K>> {}
\end{lstlisting}

A hierarquia imposta na herança de $K$ e $Kind$ limita a simulação de tipos construtores reais. Em outras linguagens, estes apenas são preenchidos por tipos, sem necessariamente impor uma classificação. Contudo, subclasses que implementem o contrato de $Kind$ mantém o controle do tipo mais interno $A$ e do mais externo $K$. Além disso, estas também podem ser utilizadas como tipos construtores pois herdam as características de $Kind$ após implementa-lo.

\subsection{Implementação de $Monad$}

A interface $Monad$, conforme~\ref{lst:monad-interface}, conta com as operações monádicas de identidade e multiplicação por meio de seu construtor de classe e do método $flatMap$. Afim de tornar $M$ um tipo construtor,  $Monad$ implementa $Kind$ e parametriza este nos tipos $A$ e $M$. Também é importante salientar a implementação de $Functor$ que mantém consistente a hierarquia dessas construções e garante a implementação de $map$.

Em sua declaração, $M$ herda $Kind$, porém não especializa o valor deste primeiro tipo. Durante a declaração de interface ou classe, apenas os tipos genéricos deste escopo estão disponíveis, e desta forma não é possível determinar qual o valor do primeiro parâmetro de tipo de $Kind$. Como existe apenas $A$ e os métodos da classe podem retornar outros valores, determina-se que $Kind$ é parametrizado pelo operador coringa.

Para a declaração de $flatMap$ utilizam-se genéricos no escopo de método. Os tipos $B$ e $M(B)$ representam a saída da operação natural de multiplicação de mónade. Com estes declarados, a função $f$ que será aplicada neste contexto consegue expressar a entrada $A$ e saída $M(B)$. Como na declaração de classe $Kind$ foi parametrizado com o operador coringa, agora é possível especializar o retorno de $flatmap$ por $Monad(M(B))$.

O método $map$ é herdado de $Functor$ e seu tipo de retorno é especializado em $Monad$. Neste,  utiliza-se o mesmo modo de declaração de $flatMap$ com genéricos no escopo de método. Sua declaração é mais simples, pois a função $f$ retorna um tipo simples $B$. Por fim, $M$ é utilizado no retorno de $map$ onde declara-se $Monad(M(B))$.

Diversas estruturas que utilizam o conceito do contexto monádico podem implementar o contrato $Monad$ da Listagem~\ref{lst:monad-interface}. Os métodos $map$ e $flatMap$ e os parâmetros de tipo exigidos pela interface visam garantir consistência entre suas implementações. Para demonstrar os benefícios de $Monad$, na Listagem~\ref{lst:maybe-class},~\ref{lst:just-class} e~\ref{lst:nothing-class} a interface $Maybe$ e suas subclasses $Just$ e $Nothing$ são implementadas.

\begin{lstlisting}[float = *, caption = {Interface $Monad$}, label = {lst:monad-interface}]
public interface Monad<A, M extends Kind<?, M>> extends Functor<A>, Kind<A, M> {

	<B, MB extends Kind<B, M>> Monad<B, M> flatMap(Function<? super A, MB> f);

	<B> Monad<B, M> map(Function<? super A, ? extends B> f);

}
\end{lstlisting}

\begin{lstlisting}[float = *, caption = {Interface $Maybe$}, label = {lst:maybe-class}]
public interface Maybe<A> extends Monad<A, Maybe<?>> {

	...
	
	default <B, MB extends Kind<B, Maybe<?>>> Maybe<B> flatMap(Function<? super A, MB> f) {
		if (isDefined()) return (Maybe<B>) f.apply(get());
		else return new Nothing<>();
	}

	default <B> Maybe<B> map(Function<? super A, ? extends B> f) {
		if (isDefined()) return Just.pure(f.apply(get()));
		else return new Nothing<>();
	}
	
	...	
	
}
\end{lstlisting}

\begin{lstlisting}[caption = {Classe $Just$}, label = {lst:just-class}]
public class Just<A> implements Maybe<A> {

	...

	public Just(A value) {
		this.value = value;
	}

	public static <A> Just<A> pure(A a) {
		return new Just<>(a);
	}
    
	...

}
\end{lstlisting}

O tipo $Maybe$ é uma mónade que encapsula um valor opcional. Esta pode conter valor e ser uma instância de $Just(A)$, ou estar vazia e corresponder a $Nothing$. Os métodos $map$ e $flatMap$ dispõem o encadeamento de funções no contexto de $Maybe$. Os construtores e métodos utilitários  como $pure$ determinam como dá-se a instanciação.

\begin{lstlisting}[caption = {Classe $Nothing$}, label = {lst:nothing-class}]
public class Nothing<A> implements Maybe<A> {

	public Nothing() {}
    
	...

}
\end{lstlisting}

Na Listagem~\ref{lst:maybe-example} demonstra-se a utilização de $Maybe$ e suas subclasses para evitar exceções em tempo de execução. O método $divide$ recebe dois argumentos do tipo $double$ e garante que divisões por zero não ocorram, retornando $Just(Double)$ ou $Nothing$. No retorno deste método,  encadeia-se uma lambda expression trivial de soma com $flatMap$. Portanto, se $n$ assumir valor zero, o retorno de $flatMap$ é $Nothing$, caso contrário teremos o valor inicial de $a$ dividido por $b$ e acrescentado em dois.

\begin{lstlisting}[caption = {Exemplo de utilização de $Maybe$}, label = {lst:maybe-example}]
public Maybe<Double> divide(double a, double b) {
	if (b == 0) return new Nothing();
	else return Just.pure(a / b);
}

...

divide(10, n).flatMap(x -> Just.pure(x + 2))
\end{lstlisting}

Consequentemente, $Maybe$ possibilita que os axiomas de identidade e associatividade de $Monad$ sejam validados. Na Listagem~\ref{lst:java-monad-laws}, os métodos $leftIdentity$, $rightIdentity$ e $associativity$ representam as leis que regem a estrutura e garantem que estas são válidas para $Maybe$, garantindo a fidelidade da interface $Monad$.

\begin{lstlisting}[caption = {Leis de $Monad$}, label = {lst:java-monad-laws}]
public void leftIdentity() {
	assertEquals(Just.pure(a).flatMap(f), f.apply(a));
}

public void rightIdentity() {
	assertEquals(m.flatMap(Just::pure), m);
}


public void associativity() {
	assertEquals(m.flatMap(f).flatMap(g), m.flatMap(x -> f.apply(x).flatMap(g)));
}
\end{lstlisting}

\paragraph{Identidade - $leftIdentity$ e $rightIdentity$} encapsular um valor em um contexto monádico não deve apresentar alterações no valor ou na estrutura da mónade.

\paragraph{Associatividade - $associativity$} a ordem na qual as funções são encadeadas em um contexto monádico não deve importar.

Todas as leis estão implementadas considerando a igualdade de objetos descrita por $equals$ e $hashcode$~\cite{gosling1995java}. O método $assertEquals$ recebe dois argumentos como valores comparativos e a equivalência dos objetos deve resultar em um tipo booleano verdadeiro, caso contrário a as leis são invalidadas.

\subsection{Problema da Generalização de Arrow}

Na declaração de $Arrow$ na Listagem~\ref{lst:java-arrow-interface}, a interface apresenta três parâmetros de tipo. Como primeiro tipo genérico, $A$ representa um tipo construtor por ser subtipo de $Kind$. O restante, $B$ e $C$, apenas explicitam os tipos de entrada e saída de $Arrow$.

Assim como $Monad$, subclasses de $Arrow$ devem utilizar seus construtores para incluir $B \rightarrow C$ em seus contextos. Além disso, o método $andThen$ define a composição de $Arrow$ por $A(B, D) = A(B, C) \circ A(C, D)$.

\begin{lstlisting}[caption = {Interface $Arrow$}, label = {lst:java-arrow-interface}]
interface Arrow<A extends Kind<?, ?>, B, C> {
	<D, AD extends Kind<D, ?>> Arrow<AD, B, D> andThen(Arrow<AD, C, D> k);
}
\end{lstlisting}

A Listagem~\ref{lst:java-wrong-kleisli-instance} declara a classe $Kleisli$. Esta implementa o contrato definido em $Arrow$ e conta com os tipos genéricos $M$, $A$ e $B$. Os argumentos e a implementação de $andThen$ foram eliminados afim de manter a simplicidade na declaração do método.


Como $Kleisli$ trabalha com tipos monádicos, seu primeiro parâmetro de tipo impõe uma ligação entre $M$ e $Monad$. O tipo genérico $A$ define a entrada da função encapsulada pelo construtor de classe e $B$ o valor encapsulado pela mónade $M$. Além disso, os tipos genéricos declarados em $Kleisli$ são repassados para $Arrow$ e consequentemente formam os tipos de entrada e saída dos métodos sobrescritos.

\begin{lstlisting}[caption = {Implementação concreta da interface $Arrow$}, label = {lst:java-wrong-kleisli-instance}]
class Kleisli<M extends Monad<B, ?>, A, B> implements Arrow<M, A, B> {

	...

	public Kleisli(Function<A, M> f) {
        this.f = f;
	}

	public <D, MD extends Kind<D, ?>> Arrow<MD, A, D> andThen() {
		...
	}
}
\end{lstlisting}

Para manter a consistência na implementação de $Kleisli$, o método $andThen$ deve retornar uma instância de $Arrow$ onde $M(D)$ extenda $Monad$. Contudo, $Arrow$ impõe restrições através de $Kind$ e estas devem ser mantidas na subclassificação. Portanto, o retorno de $andThen$ definido por $Arrow$ não pode ser expresso em $Kleisli$. Assim, a interface $Arrow$ não é suficientemente genérica de modo que possa expressar as diferentes implementações de flechas.

\subsection{Implementação de $Kleisli$}

A implementação da classe $Kleisli$ na Listagem~\ref{lst:java-right-kleisli-instance} contem os tipos genéricos $M$, $B$ e $C$. Como esta trabalha sob tipos monádicos e suas composições, $M$ é declarado como sendo um $Monad$ e representa o retorno da função encapsulada por $Kleisli$. O tipo $B$ é a entrada da função e $C$ o valor encapsulado no contexto de $M$, dado por $M(C)$.

Semelhante a $Monad$, valores são incluídos no contexto de $Kleisli$ a partir construtor de classe. Este recebe uma função $B \rightarrow M$ que é armazenada e está disponível no escopo de classe. A aplicação da função encapsulada é disponibilizada pelo método $run$.

O operador de composição é expresso pelo método $andThen$. Apesar de conter diversas declarações de tipos genéricos na assinatura do método, $andThen$ recebe uma instancia de $Kleisli$ parametrizada por $M(D)$, $C$ e $D$. Deste argumento dá-se a composição, onde o valor de $C$ resultante da aplicação de $B \rightarrow M(C)$ é passada para $C \rightarrow M(D)$ de $k$. Deste encadeamento obtemos uma nova instancia de $Kleisli$ definida por $M(D)$, $B$ e $D$.

\begin{lstlisting}[float = *, caption = {Implementação de $Kleisli$}, label = {lst:java-right-kleisli-instance}]
class Kleisli<M extends Monad<?, ?>, B, C> {

	...

	public Kleisli(Function<B, M> f) {
		this.f = f;
	}

	public M run(B b) {
		return f.apply(b);
	}

	public <D, MC extends Monad<C, MC>, MD extends Monad<D, ?>> Kleisli<MD, B, D> andThen(Kleisli<MD, C, D> k) {
		return new Kleisli<>(b -> (MD) ((MC) this.run(b)).flatMap(c -> (MC) k.run(c)));
	}
}
\end{lstlisting}

Com a implementação de $Kleisli$ é possível compor mónades de forma semelhante a cadeia de $flatMap$ e $map$. Na Listagem~\ref{lst:monad-kleisli-composition} $f$, $g$ e $h$ expressam funções na forma ${A \rightarrow M(B)}$, mais precisamente ${Integer \rightarrow Maybe(Integer)}$. O método $andThen$ em conjunto com $run$ consegue aplicar o valor passado como argumento na função encapsulada e repassa-lo para outras flechas, encadeando os valores entre as mónades.

\begin{lstlisting}[caption = {Composição monádica com $andThen$}, label = {lst:monad-kleisli-composition}]
Kleisli<Maybe<Integer>, Integer, Integer> f() {
	return new Kleisli<>(i -> Just.pure(i + 1));
}

Kleisli<Maybe<Integer>, Integer, Integer> g() {
	return new Kleisli<>(i -> Just.pure(i * 10));
}

Kleisli<Maybe<Integer>, Integer, Integer> h() {
	return new Kleisli<>(i -> Just.pure(i - 5));
}

h().andThen(f().andThen(g())).run(5);

\end{lstlisting}

$Kleisli$ mantém as regras das estruturas subjacentes. A aplicação de $h$, $f$, $g$ e $run(5)$ por $andThen$ resulta em uma instância $Just(10)$. De maneira semelhante, se umas destas funções retornar  $Nothing$, a cadeia não é executada e retorna $Nothing$.

Como todas as estruturas implementadas, $Kleisli$ conta com as leis de composição. A Listagem~\ref{lst:kleisli-laws} demonstra a validade dos axiomas de identidade e associatividade.

\begin{lstlisting}[caption = {Leis de $Kleisli$}, label = {lst:kleisli-laws}]

public void identity() {
	... kf = new Kleisli<>(f);
	
	assertEquals(kf.run(a), f.apply(a));
}

public void associativity() {
	assertEquals(g.andThen(h).andThen(f).run(a), 							 f.andThen(g.andThen(h)).run(a));
}
\end{lstlisting}

\paragraph{Identidade - $identity$} a função $f$ com assinatura na forma $A \rightarrow B$ é encapsulada por $Kleisli$ e aplicada com $a$. A mesma função $f$ fora do contexto de $Kleisli$ é aplicada também com $a$. A integridade do axioma de identidade está na igualdade do valor obtido de ambas aplicações.

\paragraph{Associatividade - $associativity$} 

\section{TRABALHOS RELACIONADOS}

\section{CONCLUSÃO}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}