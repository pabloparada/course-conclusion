\documentclass[10pt, conference]{IEEEtran}

\usepackage{cite}
\usepackage{listings}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{textcomp}

% configs listings
\lstset{
	basicstyle = \footnotesize\tt,
	breakatwhitespace = true,
	breaklines = true,
	captionpos = b,
	extendedchars = true,
	language = Java,
	frame = single,
	keywordstyle = \bf,
	showspaces = false,
	showstringspaces = false,
	showtabs = false,
	tabsize = 2,
	belowcaptionskip = 1em,
    belowskip = 2em,
    xleftmargin = 5pt,
	xrightmargin = 5pt
}

\begin{document}

\title { 
	Category Theory \\
	Arrows e Monads \\
	em Java 
}

\author{

	\IEEEauthorblockN{ Mozart L. Siqueira }
	\IEEEauthorblockA{
		Ciências da Computação \\
		Centro Universitário La Salle - Unilasalle \\
		Email: mozarts@unilasalle.edu.br
	}

	\and	
	
	\IEEEauthorblockN { Pablo M. Parada }
	\IEEEauthorblockA { 
		Ciências da Computação \\
		Centro Universitário La Salle - Unilasalle \\
		Email: pablo.paradabol@gmail.com
	}
}
					  
\maketitle

\begin{abstract}

\textcolor{red}{<escrever>}

\end{abstract}

\begin{IEEEkeywords}

\textcolor{red}{<escrever>}

\end{IEEEkeywords}

\section{INTRODUÇÃO}
\label{sec:intro}

<escrever>

\section{SOBRE O PARADIGMA FUNCIONAL}
\label{sec:func-para}
Influenciado principalmente pelo desenvolvimento do lambda calculus \cite{hudak1989conception}, compondo o grupo da programação declarativa, o paradigma funcional utiliza-se da idéia de expressar computações através de funções combinadas em expressões. Neste, funções determinam o que deverá ser computado, ao invés de como sera computado \cite{louden2011programming}. Programas são construídos através da composição, tal que funções triviais (ou building blocks) são combinadas dando origem a novas funções que descrevem computações mais complexas.

Building blocks não devem fazer uso de variáveis que dependam de estado, isso significa que a computação deve ser pura e sem efeitos indesejados (ou side-effects). Também destaca-se o princípio de imutabilidade, onde o valor é de uma variável é determinado em sua criação, não permitindo novas atribuições posteriormente.

É possível afirmar que ao expressar um programa em uma linguagem funcional, obtem-se uma maneira concisa de solucionar problemas, dado que este constitui-se de operações e objetos atômicos e regras gerais para sua composição \cite{michaelson2011introduction}. Estas qualidades são apreciadas nos tempos atuais, onde há necessidade de tratar os problemas oriundos do não-determinismo. Assim, o paradigma funcional mostra-se capaz, inclusive de influenciar outras linguagens como Java \cite{jsr335}.

\subsection{Lambda Expressions e Anonymous Inner Classes}
Ao fornecer funções de primeira classe (também lambda expressions ou closures), a linguagem Java habilita a substituição de annonymous inner classes (AIC) de forma transparente. Contudo, apesar destas expressarem o mesmo comportamento a nível de código, ambas funcionalidades possuem diferentes implementações sob a Máquina Virtual Java (JVM). Por exemplo, na odernação de inteiros podemos utilizar uma AIC em conjunto do método sort da classe Arrays tal que

\begin{lstlisting}[caption={Sort - Anonymous Inner Class}, label={lst:array-aic-sort}]
Integer[] integers = new Integer[]{5, 4, 3, 2, 1};

Arrays.sort(integers, new Comparator<Integer>() {
    public int compare(Integer a, Integer b) {
        return a.compareTo(b);
    }
});
\end{lstlisting}

obtem-se como retorno do método, um array com elementos ordenados. Entretanto, o mesmo método pode ser simplificado por uma lambda expression através de

\begin{lstlisting}[caption={Lambda Expressions}]
Arrays.sort(integers, (a, b) -> a.compareTo(b));
\end{lstlisting}

que descreve a mesma expressão sem os encargos impostos por AIC.

Conforme afirmou-se anteriormente, AIC e closures de fato diferem sob a JVM. AIC são compiladas, ou seja, geram novos arquivos contendo declarações de classes. Além do mais, ao utilizar a palavra reservada \textbf{this} referencia-se a própria instância anônima. Como representam instâncias de uma classe, estas devem ser carregadas pelo class loader e seus construtores invocados pela máquina virtual. Ambas etapas consomem memória, tanto heap para alocação de objetos quanto permgem, utilizada para guardar metadados, definições de classes e métodos \cite{hunt2011java}.

Diferentemente de AIC, lambdas postergam a estratégia de compilação para em tempo de execução, utilizando a instrução invokedynamic \cite{goetz2012translation}. Funções são traduzidas para métodos estáticos vinculados ao arquivo da classe correspondente a sua declaração, eliminando o consumo de memória. Agora, ao referir-se a \textbf{this}, a classe que delimita a lamda expression é acessada, ao contrário de AIC que acessa sua própria instância. Por fim, closures fornecem formas mais expressivas de representar comportamentos.

\section{CATEGORY THEORY E SUAS APLICAÇÕES}

Afim de demonstrar as relações entre estruras e sistemas matemáticos \cite{maclane1971mat}, a Category Theory (CT) estabelece uma linguagem formal capaz de encontrar aplicabilidade em várias áreas da ciência \cite{spivak2014cts}. Na computação seu emprego fornece abstrações capazes de demonstrar as estruturas de programas e como dá-se sua composição. Com base nisto, Haskell foi capaz de resolver um dos problemas do The Awkward Squad \cite{jones2001tacklingthe}, onde fundamentalmente laziness e side-effects eram incompatíveis até o surgimento de monads \cite{mogi1991monad} na linguagem. A partir de então, diversas outras estruturas como categories, functors, arrows foram implementadas em Haskell. 

\subsection{Category -- Objetos e Morfismos}

Uma category $C$ consiste em uma coleção de objetos e uma coleção de relações entre estes objetos, chamados morfismos.\\

\textcolor{red}{<adicionar notações matemáticas e diagramas>}

\subsection{Functor -- Categories e Morfismos}

Um functor $F$ consiste em um morfismo entre duas categories \cite{maclane1971mat}. Estes morfismos, chamados homomorfismos, tem como característica a preservação de estrutura de $F$. Assim como categories, functors devem satisfazer os axiomas de associatividade e identidade.\\

\textcolor{red}{<adicionar notações matemáticas e diagramas>}

\subsection{Monad -- Endofunctor e Transformações Naturais}

Endofunctors equipados com as natural transformations unit e multiplication \cite{maclane1971mat} são chamados de monad. Define-se endofunctors como functors cujos morfismos dão-se em uma mesma category. Além disso, natural transformations são morfismos entre functors, tendo como principal característica a preservação de estrutura. Como todas as estruturas já mencionadas, monads também devem satisfazer as propriedades de associatividade e identidade.\\

\textcolor{red}{<adicionar notações matemáticas e diagramas comutativos>}

\subsection{Arrow -- Kleisli Triples}

A partir de um monad podemos construir kleisli triples. Podemos pensar em kleisli triples como uma outra forma de representar sintaticamente um monad. Similar a monads, estas também obedecem as propriedades de associatividade e comutatividade.\\

\textcolor{red}{<adicionar notações matemáticas e diagramas comutativos>}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}