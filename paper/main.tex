\documentclass[10pt, conference]{IEEEtran}

\usepackage[numbers,sort&compress,square]{natbib}
\usepackage{listings}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{textcomp}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{amsmath}

\usetikzlibrary{matrix, arrows}

% configs listings
\renewcommand{\lstlistingname}{Listagem}
\lstset{
	basicstyle = \footnotesize\tt,
	breakatwhitespace = true,
	breaklines = true,
	captionpos = b,
	extendedchars = true,
	language = Java,
	frame = single,
	keywordstyle = \bf,
	showspaces = false,
	showstringspaces = false,
	showtabs = false,
	tabsize = 2,
	abovecaptionskip = 1em,
	belowcaptionskip = 1em,
	aboveskip = 2em,
    belowskip = 5pt,
    xleftmargin = 5pt,
	xrightmargin = 5pt
}

% configs footnotes
\renewcommand\footnoterule{\kern-3pt \hrule width 2in \kern 2.6pt}

\begin{document}
\bstctlcite{IEEEexample:BSTcontrol}

\title { 
	Teoria das Categorias \\
	Flechas e Mónades \\
	em Java 
}

\author{

	\IEEEauthorblockN{ Mozart L. Siqueira¹, Pablo M. Parada² }
	\IEEEauthorblockA{
		Ciência da Computação \\
		Centro Universitário La Salle - Unilasalle \\
		E-mail: mozarts@unilasalle.edu.br¹, pablo.paradabol@gmail.com²
	}
}
					  
\maketitle

\thispagestyle{plain}
\pagestyle{plain}

\begin{abstract}

\textcolor{red}{<escrever>}

\end{abstract}

\begin{IEEEkeywords}

\textcolor{red}{<escrever>}

\end{IEEEkeywords}

\section{INTRODUÇÃO}
\label{sec:intro}

<escrever>

\section{PARADIGMA FUNCIONAL}
\label{sec:func-para}

Influenciado principalmente pelo desenvolvimento do lambda calculus~\cite{hudak1989conception}, compondo o grupo da programação declarativa, o paradigma funcional utiliza-se da ideia de expressar computações através de funções combinadas em expressões. Neste, funções determinam o que deverá ser computado, ao invés de como sera computado~\cite{louden2011programming}. Programas são construídos através da composição, tal que funções triviais (building blocks) são combinadas dando origem a novas funções que descrevem computações mais complexas.

Building blocks não devem fazer uso de variáveis que dependam de estado, isso significa que a computação deve ser pura e sem efeitos colaterais (side-effects). Também destaca-se o princípio de imutabilidade, onde o valor de uma variável é determinado em sua criação, não permitindo novas atribuições posteriormente. Ao expressar um programa em uma linguagem funcional obtém-se uma maneira concisa de solucionar problemas, sendo que este constitui-se de operações e objetos atômicos e regras gerais para sua composição~\cite{michaelson2011introduction}.

Tais propriedades são apreciadas nos tempos atuais, visto que a Lei de Moore nos fornece cada vez mais núcleos, não necessariamente núcleos mais rápidos~\cite{jsr335}. Em programas não-determinísticos, múltiplas threads podem alterar os dados representados por objetos imutáveis sem ocasionar os diversos problemas já conhecidos como dead locks e race conditions. Além do thread safety oferecido pela propriedade de imutabilidade, há também o conceito de funções transparentes referencialmente, ou seja, funções que não utilizam variáveis de estado. Em ambientes distribuídos onde a execução é subdivida em diferentes threads, a transparência referencial garante sempre o mesmo retorno, dados os mesmos argumentos.

O paradigma funcional expressa programas através de composições mantendo a imutabilidade e a transparência referencial, portanto apresenta caraterísticas importantes para os tempos atuais. A complexidade intrínseca à ambientes distribuídos é reduzida. Programas completos são vistos como apenas uma aplicação de função.

\section{JAVA LAMBDA EXPRESSIONS}

Na última década muitos dos problemas encontrados -- como enviar não só dados, mas também comandos através de redes -- já foram solucionados em linguagens que suportam o paradigma funcional~\cite{fischer2015java}. Assim, linguagens multi-paradigma têm adicionado suporte à estas mesmas estruturas, aumentando sua flexibilidade e ganho para com os desenvolvedores. O suporte a lambda expressions em Java não tem como objetivo apenas substituir Anonymous Inner Classes, mas também ser capaz de trazer os benefícios deste paradigma ao ponto de incrementar o ecossistema da linguagem.

\subsection{Lambda Expressions e Anonymous Inner Classes}
Ao fornecer suporte a funções de primeira classe, também chamadas de lambda expressions ou closures\footnote{Lambda expressions ou closures são funções que não exigem vínculos de classe, como exemplo podendo ser atribuída a uma variável. Com esta caraterística, uma função atua como dado, ou seja, pode ser passada como argumento para outras funções.}, a linguagem Java habilita a substituição de annonymous inner classes (AIC) de forma transparente. Conforme a Listagem~\ref{lst:array-aic-sort}, em Java a ordenação de inteiros pode ser implementada a partir de uma AIC em conjunto do método sort da classe Arrays.

\begin{lstlisting}[caption={Sort - Anonymous Inner Class}, label={lst:array-aic-sort}]
Integer[] integers = new Integer[]{5, 4, 3, 2, 1};

Arrays.sort(integers, new Comparator<Integer>() {
    public int compare(Integer a, Integer b) {
        return a.compareTo(b);
    }
});
\end{lstlisting}

Neste trecho de código o método \textit{sort} recebe como primeiro argumento um array de inteiros (já declarado na variável \textit{integers}) e como segundo qualquer instância que satisfaça o contrato de \textit{Comparator}. Assim, para satisfazer o segundo argumento, instância-se uma AIC através da palavra reservada \textbf{new} que implementa o método \textit{compare} declarado no contrato.

Entretanto, com closures o mesmo método \textit{sort} pode ter seus argumentos simplificados. Conforme demonstrado na Listagem~\ref{lst:array-lambda-sort}, ao invés de instanciar uma AIC, uma lambda expression é passada como segundo argumento, removendo a necessidade de instanciação de uma classe e a implementação de um contrato imposto por \textit{Comparator}.

\begin{lstlisting}[caption={Sort - Lambda Expression}, label={lst:array-lambda-sort}]
Arrays.sort(integers, (a, b) -> a.compareTo(b));
\end{lstlisting}

De fato, apesar de expressarem o mesmo comportamento a nível de código, ambas funcionalidades possuem diferentes implementações sob a Máquina Virtual Java (JVM). AIC são compiladas, ou seja, geram novos arquivos contendo declarações de classes. Além do mais, ao utilizar a palavra reservada \textbf{this} referencia-se a própria instância anônima. Como representam instâncias de uma classe, estas devem ser carregadas pelo classloader e seus construtores invocados pela máquina virtual. Ambas etapas consomem memória, tanto heap~\cite{hunt2011java} para alocação de objetos quanto permgem\footnote{Área de memória limitada separada da heap chamada Permanent Generation que possui a função de armazenar objetos de geração permanente como metadados, classes e métodos.}.

Diferentemente de AIC, lambdas postergam a estratégia de compilação para em tempo de execução, utilizando a instrução invokedynamic~\cite{goetz2012translation}. Funções são traduzidas para métodos estáticos vinculados ao arquivo da classe correspondente a sua declaração, eliminando o consumo de memória. Agora, ao referir-se a \textbf{this}, a classe que delimita a lambda expression é acessada, ao contrário de AIC que acessa sua própria instância.

Dessa forma, o suporte a lambda expressions traz benefícios para os usuários da linguagem. Tal funcionalidade está além de uma mera substituição, pois acrescenta um novo paradigma no ecossistema Java.

\section{TEORIA DAS CATEGORIAS E SUAS ESTRUTURAS}
A Teoria das Categorias (TC) foi inventada no início dos anos 1940 por Samuel Eilenberg e Sunders Mac Lane~\cite{eilenbergmaclane1945naturalequivalences} como uma ponte entre os diferentes campos da topologia e álgebra~\cite{spivak2014cts}. Afim de demonstrar as relações entre estruturas e sistemas matemáticos~\cite{maclane1971mat}, a TC estabelece uma linguagem formal capaz de encontrar aplicabilidade em várias áreas da ciência. Por volta dos anos 1980, computação e TC passaram a ser consideradas áreas correlatas de estudo~\cite{carlos2006caracteristicas}.

Aplicações do modelo categorial ocorrem na composição de funções encorajada pelo paradigma funcional. Além do mais, em linguagens de programação, o estudo dos tipos pode ser representado através de categorias. Muitos modelos computacionais que fazem uso de estruturas de dados como grafos podem ser generalizados para categorias de grafos. Portanto, tais aplicações demonstram a capacidade de abstração e a importância da TC para a computação.

\begin{figure}[!h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
    	\matrix (m) [
        	    matrix of math nodes,
            	row sep=3em,
	            column sep=5em,
				text height=2ex, text depth=0.5ex
            	] {
			A & B \\
			  & C \\
        };
    	\path[->]
        	(m-1-1) edge node[above] {$f$} (m-1-2)
			(m-1-2) edge node[right] {$g$} (m-2-2)
			(m-1-1) edge node[left = 0.9cm, below = 0.001cm] {$h =$ $g \circ f$} (m-2-2);
	\end{tikzpicture}
\caption{Funções entre coleções de objetos}
\label{fig:f-g-composition}
\end{figure}

Tal como a Teoria dos Grupos\footnote{Teoria que estuda as estruturas algébricas de grupos. Um grupo é formado por um conjunto de elementos finito ou infinito associado a uma operação binária, como por exemplo a adição ou multiplicação.} abstrai a ideia do sistema de permutações como simetrias de um objeto geométrico, a TC manifesta-se como um sistema de funções entre conjuntos de objetos~\cite{awodey2010category}. Esta abstração pode ser vista a partir da Figura~\ref{fig:f-g-composition}, onde os conjuntos de objetos são representado por $A$, $B$ e $C$. Nesta mesma estrutura, $f$ e $g$ denotam os morfismos entre os diferentes conjuntos de objetos, tal que ${f: A \rightarrow B}$ e ${g: B \rightarrow C}$. Por fim, $h$ expressa a ideia de composição, sendo produto da união dos morfismos $f$ e $g$. 

A TC nasceu como uma ferramenta matemática, com propósito de estudar a relação objetos e morfismos. Contudo, tal conceito tornou-se uma ferramenta utilizada por diversas áreas da ciência. Na computação, diversos problemas são abstraídos através de estruturas da TC, pois ajudam na sua resolução.

\subsection{Categoria -- Objetos e Morfismos}
\label{subsec:sub-cat}
Uma categoria consiste em uma coleção de coisas, todas relacionadas de algum modo. As coisas são nomeadas de objetos e as relações de morfismos \cite{spivak2014cts}.\\

\textbf{Definição}~\cite{spivak2014cts, maclane1971mat}: define-se a categoria $C$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item uma coleção ${Ob(C)}$, contendo os objetos de $C$;
	\item para cada par ${a, b \in Ob(C)}$, um conjunto ${Hom_C(a, b)}$ chamado de morfismos de $a$ para $b$;
	\item para cada objeto ${a \in Ob(C)}$, um morfismo de \textit{identidade} em $a$ denotado por ${id_a \in Hom_C(x, a)}$;
	\item para cada três objetos ${a, b, c \in Ob(C)}$, uma função de composição $\circ: Hom_C(b, c) \times Hom_C(a, b) \rightarrow Hom_C(a, c)$;
\end{enumerate}

Dado os objetos $a, b \in Ob(C)$, denota-se o morfismo $f \in Hom_C(a, b)$ por $f: a \rightarrow b$; onde $a$ é o domínio e $b$ o contradomínio.\\	

Estas operações em $C$ devem satisfazer os seguintes axiomas:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a, b \in Ob(C)$ e todo morfismo $f: a \rightarrow b$, tem-se $id_a \circ f = f = id_b \circ f$;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c, d \in Ob(C)$ e os morfismos $f: a \rightarrow b$, $g: b \rightarrow c$ e $h: c \rightarrow d$. Então $(h \circ g) \circ f = h \circ (g \circ f)$.
\end{enumerate}

Ambos axiomas podem ser representados pelos diagramas comutativos das Figura~\ref{fig:comut-ident} e Figura~\ref{fig:comut-assoc}.

\begin{figure}[h]
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						]{
							a & a \\
							b & b \\
						};

					\path[->]
						(m-1-1) edge node[above] {$id_a$} (m-1-2)
						(m-1-1) edge node[left] {$f$} (m-2-1)
						(m-1-2) edge node[above] {$f$} (m-2-1)
						(m-1-2) edge node[right]  {$f$} (m-2-2)
						(m-2-1) edge node[above] {$id_b$} (m-2-2);
			\end{tikzpicture}
			\caption{Identidade}
			\label{fig:comut-ident}
	\end{minipage}
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						] {
							a & b \\
							c & d \\
						};
					\path[->]
						(m-1-1) edge node[above] {$f$} (m-1-2)
						(m-1-1) edge node[left] {$g \circ f$} (m-2-1)
						(m-1-2) edge node[above] {$g$} (m-2-1)
						(m-1-2) edge node[right]  {$h \circ g$} (m-2-2)
						(m-2-1) edge node[above] {$h$} (m-2-2);
			\end{tikzpicture}
			\caption{Associatividade}
			\label{fig:comut-assoc}
	\end{minipage}
\end{figure}

\subsection{Funtor -- Morfismos entre Categorias}

Um funtor é um mapeamento entre duas categorias de tal modo que o domínio, contradomínio, objetos e morfismos são preservados~\cite{awodey2010category}.\\

\textbf{Definição}~\cite{maclane1971mat, spivak2014cts}: para as categorias $C$ e $D$, um funtor $F:C \rightarrow D$ com domínio $C$ e contradomínio $D$ consiste em duas funções relacionadas. São elas:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item a função de objeto $F$ que atribui cada objeto $a \in Ob(C)$ para um objeto $F(a) \in Ob(D)$;
	\item e a função de flecha (também chamada $F$) que atribui cada morfismo $f: a \rightarrow b \in Hom_C(a, b)$ para um morfismo $F(f):F(a) \rightarrow F(b) \in Hom_D(a, b)$.
\end{enumerate}

\bigskip

Tal que os seguintes axiomas são satisfeitos:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a \in Ob(C)$ existe um morfismo $F(id_a) = id_{F_{(a)}}$ que preserva a identidade;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c \in Ob(C)$ e os morfismos $f: a \rightarrow b$ e $g: b \rightarrow c$. Então $F(g \circ  f) = F(g) \circ F(f)$.
\end{enumerate}

\bigskip

Estas funções capazes de preservar as características das categorias $C$ e $D$ também podem ser ilustradas a partir da Figura~\ref{fig:func-f}.

\begin{figure}[h]
			\begin{tikzpicture}[->, >= stealth', shorten >= 1pt, auto]
				\node [above = 1cm, right = 5cm, scale=.91] (D) {$D)$};
				\node [above = 1cm, left = 1.5cm, scale=.91] (C) {$C)$};
				\node [left = 1cm, scale=.9] (a) {a};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
  				\node [right of = b, below = .4cm, node distance = 1.4cm, scale=1.1] (F) {$F \Rightarrow$};
 				\node [below of = b, node distance = 1.5cm, scale=.9] (c) {c};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
				\node [right of = b, node distance = 3.5cm, scale=.9] (fa) {F(a)};
  				\node [right of = fa, node distance = 1.5cm, scale=.9] (fb) {F(b)};
  				\node [below of = fb, node distance = 1.5cm, scale=.9] (fc) {F(c)};
				
				\path[->, every loop/.style={looseness=10}]

					(a) edge [in = 190, out = 120, loop, left] node[scale=.75] {$id_a$} (a);
					
				\path[->, every loop/.style={looseness=10}]
				
					(fa) edge [in = 190, out = 140, loop, left] node[scale=.75] {$F(id_a)$} (fa);
				
				\draw[->, shorten >= 1pt] (a)-- node[above] {$f$} (b);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				\draw[->, shorten >= 1pt] (a)-- node[left = 0.5cm, below = 0.001cm] {$g \circ f$} (c);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fb)-- node[right] {$g$} (fc);
				\draw[->, shorten >= 1pt] (fa)-- node[left = 0.7cm, below = 0.001cm] {$F(g \circ f)$} (fc);

			\end{tikzpicture}
			\caption{Funtor $F$}
			\label{fig:func-f}
\end{figure}

\subsection{Mónade -- Endofuntor e Transformações Naturais}

Podendo ser visto como um padrão estrutural que ocorre diversos ramos da matemática~\cite{spivak2014cts}, a construção fundamental mónade (também chamada de tripla) estrutura-se a partir de um endofuntor\footnote{Um funtor que mapeia uma categoria para ela mesma.} e das transformações naturais\footnote{Mapeamento entre dois funtores que possuem o mesmo domínio e contradomínio, tal que satisfaça a condição de naturalidade.} de identidade e multiplicação.\\

\textbf{Definição}~\cite{maclane1971mat, awodey2010category}: dada a mónade $T = (T, \eta, \mu)$ em uma categoria $C$ consiste em:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item um endofuntor $T$, tal que $T: C \rightarrow C$;
	\item nas transformações naturais:
	\begin{enumerate}[label={}]
		\item (\textit{Identidade}) $\eta: id_C \rightarrow T$;
       	\item (\textit{Multiplicação}) $\mu: T^2 \rightarrow T$, onde $T^2 = T \circ T$.
	\end{enumerate}
\end{enumerate}

Fazendo com que os diagramas da Figura~\ref{fig:mon-comut-ident} e Figura~\ref{fig:mon-comut-assoc} comutem, respeitando os axiomas de identidade (esquerda e direita) e associatividade.

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T & T^2 & T \\
					  &  T  &   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$\eta_T$} (m-1-2)
				(m-1-2) edge node[above] {$T_\eta$} (m-1-3)
				(m-1-1) edge node[left = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-3) edge node[right = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Identidade à Esquerda e à Direita}
	\label{fig:mon-comut-ident}
\end{figure}

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T^3 & T^2 \\
					T^2 & T   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$T_\mu$} (m-1-2)
				(m-1-1) edge node[left] {$\mu_T$} (m-2-1)
				(m-2-1) edge node[below] {$\mu$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Associatividade}
	\label{fig:mon-comut-assoc}
\end{figure}

\subsection{Flechas -- Categoria de Kleisli}

A partir de uma tripla obtemos a Categoria de Kleisli (CK), capaz de representar a mesma estrutura monádica através de uma sintaxe diferente~\cite{hill1994introduction}. Mantendo definições similares as já apresentadas em~\ref{subsec:sub-cat}, a CK destaca-se por abstrair a estrutura de objetos e morfismos sendo capaz compor o endofuntor subjacente.\\

\textbf{Definição}~\cite{maclane1971mat, pedicchio2004categorical, hill1994introduction}: dada a tripla $(T, \eta, \mu)$ sob a categoria $C$, então define-se $C_T$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item cada objeto $a \in Ob(C)$, um novo objeto $a_T$;
	\item cada morfismo $f: a \rightarrow T_b$, um novo morfismo ${f^*: a_T \rightarrow b_T}$.
\end{enumerate}

\bigskip

Dado os morfismos ${f^*: a_T \rightarrow b_T}$, $g^*: b_T \rightarrow c_T$ e ${h: c \rightarrow d_T}$ e o operador de extensão $-^*$, então:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (Composição) $g^* \circ f^* = (\mu_c \circ T(g) \circ f)^*$.
\end{enumerate}

\bigskip

Similar as outras estruturas desta seção, $C_T$ deve obedecer as seguintes leis:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (Identidade à Esquerda) $f^* \circ \eta_a = f$;
	\item (Identidade à Direita) $\eta^*_a \circ h = id_{T(a)} \circ h$;
	\item (Associatividade) $(g^* \circ (f^* \circ h)) = (g^* \circ f)^* \circ h$.
\end{enumerate}

\bigskip

\section{DEFININDO UM CONTRATO PARA MÓNADE}

A partir desta ligação, Moggi em seus trabalhos \cite{moggi1989lambdaandmonads, mogi1991notionsofcompandmonad} introduziu o conceito de mónade em Haskell. Este foi capaz de fornecer os mecanismos necessários para capacitar a solução de um dos problemas fundamentais da linguagem,  pertencente ao conjunto The Awkward Squad \cite{jones2001tacklingthe}. A partir de outros conceitos como funtores, categorias e flechas, o trabalho de Moggi foi incrementado criando novas estruturas que estão presentes nas versões mais recentes da linguagem.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}