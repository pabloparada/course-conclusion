\documentclass[10pt, conference]{IEEEtran}

% libraries preamble
\usepackage[numbers,sort&compress,square]{natbib}
\usepackage{listings}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{textcomp}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{scrextend}

% enable matrix and arrows constructs for tikz
\usetikzlibrary{matrix, arrows}

% configs listings
\renewcommand{\lstlistingname}{Listagem}

\lstdefinestyle{java-style}{basicstyle = \footnotesize\tt, breakatwhitespace = true, breaklines = true, captionpos = b, extendedchars = true, frame = none, keywordstyle = \bf, showspaces = false, showstringspaces = false, showtabs = false, tabsize = 2, abovecaptionskip = 1em, belowcaptionskip = 1em, aboveskip = 2em,     belowskip = 5pt, xleftmargin = 5pt, xrightmargin = 5pt}

\lstdefinestyle{haskell-style}{basicstyle = \footnotesize\tt, breakatwhitespace = true, breaklines = true, captionpos = b, extendedchars = true, frame = none, keywordstyle = \bf, showspaces = false, showstringspaces = false, showtabs = false, tabsize = 2, abovecaptionskip = 1em, belowcaptionskip = 1em, aboveskip = 2em,     belowskip = 5pt, xleftmargin = 5pt, xrightmargin = 5pt}

% configs footnotes
\renewcommand\footnoterule{\kern-3pt \hrule width 2in \kern 2.6pt}

\begin{document}
\bstctlcite{BSTcontrol}

\title { 
	Teoria das Categorias \\
	Flechas e Mónades \\
	em Java 
}

\author{

	\IEEEauthorblockN{ Mozart L. Siqueira¹, Pablo M. Parada² }
	\IEEEauthorblockA{
		Ciência da Computação \\
		Centro Universitário La Salle - Unilasalle \\
		E-mail: mozarts@unilasalle.edu.br¹, pablo.paradabol@gmail.com²
	}
}
					  
\maketitle

\thispagestyle{plain}
\pagestyle{plain}

\begin{abstract}

\textcolor{red}{<escrever>}

\end{abstract}

\begin{IEEEkeywords}

\textcolor{red}{<escrever>}

\end{IEEEkeywords}

\section{INTRODUÇÃO}
\label{sec:intro}

<escrever>

\section{PARADIGMA FUNCIONAL}
\label{sec:func-para}

Influenciado principalmente pelo desenvolvimento do lambda calculus~\cite{hudak1989conception}, compondo o grupo da programação declarativa, o paradigma funcional utiliza-se da ideia de expressar computações através de funções combinadas em expressões. Neste, funções determinam o que deverá ser computado, ao invés de como sera computado~\cite{louden2011programming}. Programas são construídos através da composição, tal que funções triviais (building blocks) são combinadas dando origem a novas funções que descrevem computações mais complexas.

Building blocks não devem fazer uso de variáveis que dependam de estado, isso significa que a computação deve ser pura e sem efeitos colaterais (side-effects). Também destaca-se o princípio de imutabilidade, onde o valor de uma variável é determinado em sua criação, não permitindo novas atribuições posteriormente. Ao expressar um programa em uma linguagem funcional obtém-se uma maneira concisa de solucionar problemas, sendo que este constitui-se de operações e objetos atômicos e regras gerais para sua composição~\cite{michaelson2011introduction}.

Tais propriedades são apreciadas nos tempos atuais, visto que a Lei de Moore nos fornece cada vez mais núcleos, não necessariamente núcleos mais rápidos~\cite{jsr335}. Em programas não-determinísticos, múltiplas threads podem alterar os dados representados por objetos imutáveis sem ocasionar os diversos problemas já conhecidos como dead locks e race conditions. Além do thread safety oferecido pela propriedade de imutabilidade, há também o conceito de funções transparentes referencialmente, ou seja, funções que não utilizam variáveis de estado. Em ambientes distribuídos onde a execução é subdivida em diferentes threads, a transparência referencial garante sempre o mesmo retorno, dados os mesmos argumentos.

O paradigma funcional expressa programas através de composições mantendo a imutabilidade e a transparência referencial, portanto apresenta caraterísticas importantes para os tempos atuais. A complexidade intrínseca à ambientes distribuídos é reduzida. Programas completos são vistos como apenas uma aplicação de função.

\section{JAVA LAMBDA EXPRESSIONS}

Na última década muitos dos problemas encontrados -- como enviar não só dados, mas também comandos através de redes -- já foram solucionados em linguagens que suportam o paradigma funcional~\cite{fischer2015java}. Assim, linguagens multi-paradigma têm adicionado suporte à estas mesmas estruturas, aumentando sua flexibilidade e ganho para com os desenvolvedores. O suporte a lambda expressions em Java não tem como objetivo apenas substituir Anonymous Inner Classes, mas também ser capaz de trazer os benefícios deste paradigma ao ponto de incrementar o ecossistema da linguagem.

\subsection{Lambda Expressions e Anonymous Inner Classes}
Ao fornecer suporte a funções de primeira classe, também chamadas de lambda expressions ou closures\footnote{Lambda expressions ou closures são funções que não exigem vínculos de classe, como exemplo podendo ser atribuída a uma variável. Com esta caraterística, uma função atua como dado, ou seja, pode ser passada como argumento para outras funções.}, a linguagem Java habilita a substituição de annonymous inner classes (AIC) de forma transparente. Conforme a Listagem~\ref{lst:array-aic-sort}, em Java a ordenação de inteiros pode ser implementada a partir de uma AIC em conjunto do método sort da classe Arrays.

\begin{lstlisting}[caption={Sort - Anonymous Inner Class}, style = java-style, label={lst:array-aic-sort}]
Integer[] integers = new Integer[]{5, 4, 3, 2, 1};

Arrays.sort(integers, new Comparator<Integer>() {
    public int compare(Integer a, Integer b) {
        return a.compareTo(b);
    }
});
\end{lstlisting}

Neste trecho de código o método $sort$ recebe como primeiro argumento um array de inteiros (já declarado na variável $integers$) e como segundo qualquer instância que satisfaça o contrato de $Comparator$. Assim, para satisfazer o segundo argumento, instância-se uma AIC através da palavra reservada $new$ que implementa o método $compare$ declarado no contrato.

Entretanto, com closures o mesmo método $sort$ pode ter seus argumentos simplificados. Conforme demonstrado na Listagem~\ref{lst:array-lambda-sort}, ao invés de instanciar uma AIC, uma lambda expression é passada como segundo argumento, removendo a necessidade de instanciação de uma classe e a implementação de um contrato imposto por $Comparator$.

\begin{lstlisting}[caption={Sort - Lambda Expression}, style = java-style, label={lst:array-lambda-sort}]
Arrays.sort(integers, (a, b) -> a.compareTo(b));
\end{lstlisting}

De fato, apesar de expressarem o mesmo comportamento a nível de código, ambas funcionalidades possuem diferentes implementações sob a Máquina Virtual Java (JVM). AIC são compiladas, ou seja, geram novos arquivos contendo declarações de classes. Além do mais, ao utilizar a palavra reservada \textbf{this} referencia-se a própria instância anônima. Como representam instâncias de uma classe, estas devem ser carregadas pelo classloader e seus construtores invocados pela máquina virtual. Ambas etapas consomem memória, tanto heap~\cite{hunt2011java} para alocação de objetos quanto permgem\footnote{Área de memória limitada separada da heap chamada Permanent Generation que possui a função de armazenar objetos de geração permanente como metadados, classes e métodos.}.

Diferentemente de AIC, lambdas postergam a estratégia de compilação para em tempo de execução, utilizando a instrução invokedynamic~\cite{goetz2012translation}. Funções são traduzidas para métodos estáticos vinculados ao arquivo da classe correspondente a sua declaração, eliminando o consumo de memória. Agora, ao referir-se a \textbf{this}, a classe que delimita a lambda expression é acessada, ao contrário de AIC que acessa sua própria instância.

Dessa forma, o suporte a lambda expressions traz benefícios para os usuários da linguagem. Tal funcionalidade está além de uma mera substituição, pois acrescenta um novo paradigma no ecossistema Java.

\section{TEORIA DAS CATEGORIAS E SUAS ESTRUTURAS}
A Teoria das Categorias (TC) foi inventada no início dos anos 1940 por Samuel Eilenberg e Sunders Mac Lane~\cite{eilenbergmaclane1945naturalequivalences} como uma ponte entre os diferentes campos da topologia e álgebra~\cite{spivak2014cts}. Afim de demonstrar as relações entre estruturas e sistemas matemáticos~\cite{maclane1971mat}, a TC estabelece uma linguagem formal capaz de encontrar aplicabilidade em várias áreas da ciência. Por volta dos anos 1980, computação e TC passaram a ser consideradas áreas correlatas de estudo~\cite{carlos2006caracteristicas}.

Aplicações do modelo categorial ocorrem na composição de funções encorajada pelo paradigma funcional. Além do mais, em linguagens de programação, o estudo dos tipos pode ser representado através de categorias. Muitos modelos computacionais que fazem uso de estruturas de dados como grafos podem ser generalizados para categorias de grafos. Portanto, tais aplicações demonstram a capacidade de abstração e a importância da TC para a computação.

\begin{figure}[!h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
    	\matrix (m) [
        	    matrix of math nodes,
            	row sep=3em,
	            column sep=5em,
				text height=2ex, text depth=0.5ex
            	] {
			A & B \\
			  & C \\
        };
    	\path[->]
        	(m-1-1) edge node[above] {$f$} (m-1-2)
			(m-1-2) edge node[right] {$g$} (m-2-2)
			(m-1-1) edge node[left = 0.9cm, below = 0.001cm] {$h =$ $g \circ f$} (m-2-2);
	\end{tikzpicture}
\caption{Funções entre coleções de objetos}
\label{fig:f-g-composition}
\end{figure}

Tal como a Teoria dos Grupos\footnote{Teoria que estuda as estruturas algébricas de grupos. Um grupo é formado por um conjunto de elementos finito ou infinito associado a uma operação binária, como por exemplo a adição ou multiplicação.} abstrai a ideia do sistema de permutações como simetrias de um objeto geométrico, a TC manifesta-se como um sistema de funções entre conjuntos de objetos~\cite{awodey2010category}. Esta abstração pode ser vista a partir da Figura~\ref{fig:f-g-composition}, onde os conjuntos de objetos são representado por $A$, $B$ e $C$. Nesta mesma estrutura, $f$ e $g$ denotam os morfismos entre os diferentes conjuntos de objetos, tal que ${f: A \rightarrow B}$ e ${g: B \rightarrow C}$. Por fim, $h$ expressa a ideia de composição, sendo produto da união dos morfismos $f$ e $g$. 

A TC nasceu como uma ferramenta matemática, com propósito de estudar a relação objetos e morfismos. Contudo, tal conceito tornou-se uma ferramenta utilizada por diversas áreas da ciência. Na computação, diversos problemas são abstraídos através de estruturas da TC, pois ajudam na sua resolução.

\subsection{Categoria -- Objetos e Morfismos}
\label{subsec:sub-cat}
Uma categoria consiste em uma coleção de coisas, todas relacionadas de algum modo. As coisas são nomeadas de objetos e as relações de morfismos \cite{spivak2014cts}.\\

\textbf{Definição}~\cite{spivak2014cts, maclane1971mat}: define-se a categoria $C$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item uma coleção ${Ob(C)}$, contendo os objetos de $C$;
	\item para cada par ${a, b \in Ob(C)}$, um conjunto ${Hom_C(a, b)}$ chamado de morfismos de $a$ para $b$;
	\item para cada objeto ${a \in Ob(C)}$, um morfismo de \textit{identidade} em $a$ denotado por ${id_a \in Hom_C(x, a)}$;
	\item para cada três objetos ${a, b, c \in Ob(C)}$, uma função de composição $\circ: Hom_C(b, c) \times Hom_C(a, b) \rightarrow Hom_C(a, c)$;
\end{enumerate}

Dado os objetos $a, b \in Ob(C)$, denota-se o morfismo $f \in Hom_C(a, b)$ por $f: a \rightarrow b$; onde $a$ é o domínio e $b$ o contradomínio.\\	

Estas operações em $C$ devem satisfazer os seguintes axiomas:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a, b \in Ob(C)$ e todo morfismo $f: a \rightarrow b$, tem-se $id_a \circ f = f = id_b \circ f$;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c, d \in Ob(C)$ e os morfismos $f: a \rightarrow b$, $g: b \rightarrow c$ e $h: c \rightarrow d$. Então $(h \circ g) \circ f = h \circ (g \circ f)$.
\end{enumerate}

Ambos axiomas podem ser representados pelos diagramas comutativos das Figura~\ref{fig:comut-ident} e Figura~\ref{fig:comut-assoc}.

\begin{figure}[h]
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						]{
							a & a \\
							b & b \\
						};

					\path[->]
						(m-1-1) edge node[above] {$id_a$} (m-1-2)
						(m-1-1) edge node[left] {$f$} (m-2-1)
						(m-1-2) edge node[above] {$f$} (m-2-1)
						(m-1-2) edge node[right]  {$f$} (m-2-2)
						(m-2-1) edge node[above] {$id_b$} (m-2-2);
			\end{tikzpicture}
			\caption{Identidade}
			\label{fig:comut-ident}
	\end{minipage}
	\begin{minipage}[t]{.48\linewidth}
		\centering
			\begin{tikzpicture}[baseline=(current bounding box.north)]
				\matrix (m) [
							matrix of math nodes,
							row sep=3em,
							column sep=5em,
							text height=2ex, text depth=0.5ex
						] {
							a & b \\
							c & d \\
						};
					\path[->]
						(m-1-1) edge node[above] {$f$} (m-1-2)
						(m-1-1) edge node[left] {$g \circ f$} (m-2-1)
						(m-1-2) edge node[above] {$g$} (m-2-1)
						(m-1-2) edge node[right]  {$h \circ g$} (m-2-2)
						(m-2-1) edge node[above] {$h$} (m-2-2);
			\end{tikzpicture}
			\caption{Associatividade}
			\label{fig:comut-assoc}
	\end{minipage}
\end{figure}

\subsection{Funtor -- Morfismos entre Categorias}
\label{subsec:funtor}
Um funtor é um mapeamento entre duas categorias de tal modo que o domínio, contradomínio, objetos e morfismos são preservados~\cite{awodey2010category}.\\

\textbf{Definição}~\cite{maclane1971mat, spivak2014cts}: para as categorias $C$ e $D$, um funtor $F:C \rightarrow D$ com domínio $C$ e contradomínio $D$ consiste em duas funções relacionadas. São elas:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item a função de objeto $F$ que atribui cada objeto $a \in Ob(C)$ para um objeto $F(a) \in Ob(D)$;
	\item e a função de flecha (também chamada $F$) que atribui cada morfismo $f: a \rightarrow b \in Hom_C(a, b)$ para um morfismo $F(f):F(a) \rightarrow F(b) \in Hom_D(a, b)$.
\end{enumerate}

\bigskip

Tal que os seguintes axiomas são satisfeitos:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item \textit{(Identidade)} Para todo objeto $a \in Ob(C)$ existe um morfismo $F(id_a) = id_{F_{(a)}}$ que preserva a identidade;
	\item \textit{(Associatividade)} Sejam os objetos $a, b, c \in Ob(C)$ e os morfismos $f: a \rightarrow b$ e $g: b \rightarrow c$. Então $F(g \circ  f) = F(g) \circ F(f)$.
\end{enumerate}

\bigskip

Estas funções capazes de preservar as características das categorias $C$ e $D$ também podem ser ilustradas a partir da Figura~\ref{fig:func-f}.

\begin{figure}[h]
			\begin{tikzpicture}[->, >= stealth', shorten >= 1pt, auto]
				\node [above = 1cm, right = 5cm, scale=.91] (D) {$D)$};
				\node [above = 1cm, left = 1.5cm, scale=.91] (C) {$C)$};
				\node [left = 1cm, scale=.9] (a) {a};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
  				\node [right of = b, below = .4cm, node distance = 1.4cm, scale=1.1] (F) {$F \Rightarrow$};
 				\node [below of = b, node distance = 1.5cm, scale=.9] (c) {c};
  				\node [right of = a, node distance = 1.5cm, scale=.9] (b) {b};
				\node [right of = b, node distance = 3.5cm, scale=.9] (fa) {F(a)};
  				\node [right of = fa, node distance = 1.5cm, scale=.9] (fb) {F(b)};
  				\node [below of = fb, node distance = 1.5cm, scale=.9] (fc) {F(c)};
				
				\path[->, every loop/.style={looseness=10}]

					(a) edge [in = 190, out = 120, loop, left] node[scale=.75] {$id_a$} (a);
					
				\path[->, every loop/.style={looseness=10}]
				
					(fa) edge [in = 190, out = 140, loop, left] node[scale=.75] {$F(id_a)$} (fa);
				
				\draw[->, shorten >= 1pt] (a)-- node[above] {$f$} (b);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				\draw[->, shorten >= 1pt] (a)-- node[left = 0.5cm, below = 0.001cm] {$g \circ f$} (c);
				\draw[->, shorten >= 1pt] (b)-- node[right] {$g$} (c);
				
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fa)-- node[above] {$f$} (fb);
				\draw[->, shorten >= 1pt] (fb)-- node[right] {$g$} (fc);
				\draw[->, shorten >= 1pt] (fa)-- node[left = 0.7cm, below = 0.001cm] {$F(g \circ f)$} (fc);

			\end{tikzpicture}
			\caption{Funtor $F$}
			\label{fig:func-f}
\end{figure}

\subsection{Mónade -- Endofuntor e Transformações Naturais}
\label{subsec:monad}
Podendo ser visto como um padrão estrutural que ocorre diversos ramos da matemática~\cite{spivak2014cts}, a construção fundamental mónade (também chamada de tripla) estrutura-se a partir de um endofuntor\footnote{Um funtor que mapeia uma categoria para ela mesma.} e das transformações naturais\footnote{Mapeamento entre dois funtores que possuem o mesmo domínio e contradomínio, tal que satisfaça a condição de naturalidade.} de identidade e multiplicação.\\

\textbf{Definição}~\cite{maclane1971mat, awodey2010category}: dada a mónade $T = (T, \eta, \mu)$ em uma categoria $C$ consiste em:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item um endofuntor $T$, tal que $T: C \rightarrow C$;
	\item nas transformações naturais:
	\begin{enumerate}[label={}]
		\item (\textit{Identidade}) $\eta: id_C \rightarrow T$;
       	\item (\textit{Multiplicação}) $\mu: T^2 \rightarrow T$, onde $T^2 = T \circ T$.
	\end{enumerate}
\end{enumerate}

Fazendo com que os diagramas da Figura~\ref{fig:mon-comut-ident} e Figura~\ref{fig:mon-comut-assoc} comutem, respeitando os axiomas de identidade (esquerda e direita) e associatividade.

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T & T^2 & T \\
					  &  T  &   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$\eta_T$} (m-1-2)
				(m-1-2) edge node[above] {$T_\eta$} (m-1-3)
				(m-1-1) edge node[left = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-3) edge node[right = 0.2cm, below = 0.001cm] {$=$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Identidade à Esquerda e à Direita}
	\label{fig:mon-comut-ident}
\end{figure}

\begin{figure}[h]
\centering
	\begin{tikzpicture}[baseline=-0.8ex]
		\matrix (m) [
					matrix of math nodes,
					row sep=3em,
					column sep=5em,
					text height=2ex, text depth=0.5ex
				]{
					T^3 & T^2 \\
					T^2 & T   \\
				};

			\path[->]
				(m-1-1) edge node[above] {$T_\mu$} (m-1-2)
				(m-1-1) edge node[left] {$\mu_T$} (m-2-1)
				(m-2-1) edge node[below] {$\mu$} (m-2-2)
				(m-1-2) edge node[right] {$\mu$} (m-2-2);
	\end{tikzpicture}
	\caption{Associatividade}
	\label{fig:mon-comut-assoc}
\end{figure}

\subsection{Flechas -- Categoria de Kleisli}
\label{subsec:arrow}
A partir de uma tripla obtemos a Categoria de Kleisli (CK), capaz de representar a mesma estrutura monádica através de uma sintaxe diferente~\cite{hill1994introduction}. Mantendo definições similares as já apresentadas em~\ref{subsec:sub-cat}, a CK destaca-se por abstrair a estrutura de objetos e morfismos sendo capaz compor o endofuntor subjacente.\\

\textbf{Definição}~\cite{maclane1971mat, pedicchio2004categorical, hill1994introduction}: dada a tripla $(T, \eta, \mu)$ sob a categoria $C$, então define-se $C_T$ como:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item cada objeto $a \in Ob(C)$, um novo objeto $a_T$;
	\item cada morfismo $f: a \rightarrow T_b$, um novo morfismo ${f^*: a_T \rightarrow b_T}$.
\end{enumerate}

\bigskip

Dado os morfismos ${f^*: a_T \rightarrow b_T}$, $g^*: b_T \rightarrow c_T$ e ${h: c \rightarrow d_T}$ e o operador de extensão $-^*$, então:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (\textit{Composição}) $g^* \circ f^* = (\mu_c \circ T(g) \circ f)^*$.
\end{enumerate}

\bigskip

Similar as outras estruturas desta seção, $C_T$ deve obedecer as seguintes leis:

\begin{enumerate}[label={}, leftmargin = 2em, topsep = 0pt, itemsep = 1ex,partopsep = 1ex, parsep = 1ex]
	\item (\textit{Identidade à Esquerda}) $f^* \circ \eta_a = f$;
	\item (\textit{Identidade à Direita}) $\eta^*_a \circ h = id_{T(a)} \circ h$;
	\item (\textit{Associatividade}) $(g^* \circ (f^* \circ h)) = (g^* \circ f)^* \circ h$.
\end{enumerate}

\bigskip

\section{APLICAÇÃO EM HASKELL}

As funções do paradigma funcional podem ser vistas como morfismos na categoria dos tipos. Percebendo estas relações, Wadler~\cite{peyton1993imperative, wadler1995monads, wadler1992comprehending, wadler1992essence} utilizou o conceito de mónade para estruturar programas puramente funcionais em Haskell. Assim, o primeiro problema pertencente ao conjunto Awkward Squad foi solucionado~\cite{jones2001tacklingthe}.

A introdução da mónade para E/S (entrada e saída) padronizou a maneira de executar  estas ações e encapsular seus efeitos colaterais. Assim, outras mónades foram adicionadas à linguagem, estendendo as bibliotecas padrões para fornecer suporte a exceções, nulidade, concorrência, etc. Logo, mónades trouxeram utilidade para a linguagem, pois confrontaram o Awkward Squad~\cite{jones2001tacklingthe}.

Com a rápida adoção de mónades para a solução de problemas envolvendo E/S, constatou-se que outros conceitos da TC também poderiam ser aproveitados. Qualquer estrutura recursiva (listas, mapas, árvores, grafos) que possa ser iterada é representada por um funtor. A categoria de Haskell, chamada Hask, preocupa-se em tratar tipos como objetos e funções como morfismos, fornecendo funções de composição e identidade.

Type classes definem comportamentos genéricos que podem ser implementados por um conjunto variado de tipos. Esta funcionalidade tornou a implementação das estruturas previamente mencionadas disponíveis para qualquer tipo de dado, dependendo apenas da implementação de suas instancias~\cite{o2008real}.

\begin{figure}[h]
\centering
	\scalebox{.85}{
		\input{images/typeclassopedia.tex}
	}
	\bigskip
	\caption[Typeclass Hierarchy]{Hierarquia de type classes\footref{fnt:typeclassopedia}}
	\label{fig:typeclassopedia}
\end{figure}

\addtocounter{footnote}{1}
\footnotetext{Fonte:~\url{https://wiki.haskell.org/Typeclassopedia}. Acessado em 17/09/2015.\label{fnt:typeclassopedia}}
	
Conforme a Typeclassopedia~\cite{web2015typeclassopedia}, a Figura~\ref{fig:typeclassopedia} demonstra as relações entre as type classes, identificadas por flechas tracejadas e pontilhadas:

\begin{enumerate}[label=(\alph*), leftmargin=3em, topsep = 0pt, itemsep = 1ex, partopsep = 1ex, parsep = 1ex]
	\item (\textit{Tracejadas}) Determinam relações de é-um, ou seja, se existe uma flecha de $A$ para $B$, então todo $B$ é um $A$;
	\item (\textit{Pontilhadas}) Indicam algum tipo de relação, como por exemplo a equivalência entre $Monoid$ e $MonadPlus$.
\end{enumerate}

A implementação de uma type class pode ser visualizada na Listagem~\ref{lst:type-class-eq}, onde a primeira declaração incorpora uma nova classe com nome $Eq$, uma variável de tipo $a$ e um comportamento explicitado pela função $equals$. 

\begin{lstlisting}[caption={Type class Eq\protect\footref{fnt:type-class-eq}}, style=haskell-style, label={lst:type-class-eq}]
class Eq a where
	equals :: a -> a -> Bool
\end{lstlisting}

Na Listagem~\ref{lst:instance-eq}, instancia-se $Eq$ para os tipos $Int$ e $Char$. A primeira instancia declara que $Int$ pertence a $Eq$, e que a implementação de igualdade de inteiros é dada por $primEqInt$. Similarmente, $Char$ pertence $Eq$ e fornece a implementação de igualdade por $primEqChar$. Logo, como $a$ é um parâmetro de tipo, as assinaturas de $primEqInt$ e $primEqChar$ são tipadas ${Int \rightarrow Int \rightarrow Bool}$ e ${Char \rightarrow Char \rightarrow Bool}$ consecutivamente~\cite{hall1996type}.

\begin{lstlisting}[caption={Instancias Eq\protect\footref{fnt:type-class-eq}}, style=haskell-style, label={lst:instance-eq}]
instance Eq Int where
	equals = primEqInt
	
instance Eq Char where
	equals = primEqChar
\end{lstlisting}
	
\addtocounter{footnote}{1}
\footnotetext{Fonte: C. V. Hall \textit{et al.}, Type Classes in Haskell, p. 3, 1996.\label{fnt:type-class-eq}}

Com a instancia de $Eq \; Int$ é possível comparar dois inteiros tal que ${equals({1 + 1}, 2)}$ retorna $True$; ou ${equals({1 + 1}, 0)}$ retorna $False$. De maneira similar, com $Eq \; Char$ é possível comparar dois caracteres, onde ${equals('a', {'a'})}$ retorna $True$; ou ${equals('a', {'b'})}$ retorna $False$.

\subsection{Monad}

Para a programação funcional, mónades oferecem um contexto computacional que encapsula efeitos colaterais. Além disso, tal contexto monádico permite o encadeamento de funções que operam sob um determinado tipo. Em Haskell, esta abstração é expressa através da type class $Monad$.

\begin{lstlisting}[caption={Type class Monad\protect\footref{fnt:haskell-language-report}}, style=haskell-style, label={lst:type-class-monad}]
class Monad m where
	(>>=)  :: m a -> (a -> m b) -> m b
	(>>)   :: (>>) m a -> m b -> m b
	return :: a -> m a
\end{lstlisting}

Conforme a Listagem~\ref{lst:type-class-monad}, a type class $Monad$ consiste em um tipo construtor $m$ e as operações $>>=$, $>>$ e $return$. A operação $>>$ existe apenas como um facilitador para a composição de funções no contexto $m$. $>>=$ e $return$ são equivalentes as transformações naturais de multiplicação e identidade.

A operação $return$ encapsula o tipo $a$ no contexto monádico $m\;a$ e retorna este como resultado. A próxima é bind, declarada simbolicamente por $>>=$, que habilita o encadeamento de funções. Bind aplica a função $a \rightarrow m\;b$ no contexto monádico $m\;a$, retornando uma nova instancia de $Monad$ do tipo $m\;b$.

Todas instâncias de $Monad$ devem seguir as leis monádicas de associatividade e identidade. Estes axiomas são demonstrados na Listagem~\ref{lst:monad-laws}.

\begin{lstlisting}[caption={Monad - Identidade e Associatividade\protect\footref{fnt:haskell-language-report}}, style=haskell-style, label={lst:monad-laws}]
return a >>= k  =  k a
m >>= return  =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
\end{lstlisting}

A possibilidade de encadear funções com $>>=$ é tão importante que diversas linguagens funcionais oferecem suporte sintático para mónades. Em Haskell, esta sintaxe especial é chamada de \textbf{do notation}~\cite{marlow2010haskell}.

\begin{lstlisting}[caption={Encadeando Funções com Bind e Then\protect\footref{fnt:haskell-language-report}}, style=haskell-style, label={lst:func-chaining}]
putStr "x: " >>
getLine >>= \l -> 
return (words l)
\end{lstlisting}

Na Listagem~\ref{lst:func-chaining} as funções $putStr$ e $getLine$ são encadeadas pelos operadores $>>$ e $>>=$. Estas mesmas funções podem ser encadeadas utilizando a utilizando o suporte sintático de \textbf{do notation}, conforme a Listagem~\ref{lst:do-notation}.

\begin{lstlisting}[caption={Encadeando Funções com Do Notation\protect\footref{fnt:haskell-language-report}}, style=haskell-style, label={lst:do-notation}]
do 
	putStr "x: "
	l <- getLine
	return (words l)
\end{lstlisting}

Com esta notação, um código pertencente ao paradigma funcional é escrito de forma imperativa, ou seja, a computação é declarada passo a passo. Assim, obtém-se uma sintaxe simplificada para expressar efeitos colaterais em linguagens puramente funcionais como Haskell.

\addtocounter{footnote}{1}
\footnotetext{Fonte: S. Marlow \textit{et al.}, Haskell 2010 Language Report, p. 25--81, 2010.\label{fnt:haskell-language-report}}

\subsection{Arrow}

\addtocounter{footnote}{1}
\footnotetext{Fonte: A. Courtney e E. Conal, Genuinely functional user interfaces, p. 5, 2001.\label{fnt:arrow-user-interface}}

\addtocounter{footnote}{1}
\footnotetext{Fonte: \url{http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html}. Acessado em: 26/09/2015.\label{fnt:prelude}}

Conforme o exemplo de programação tácita~\footnote{Um paradigma de programação no qual as funções não identificam seus argumentos, em vez disso são construídas a partir de funções combinatórias que manipulam os argumentos.} da Listagem~\ref{lst:func-count}, Hughes~\cite{hughes2005programming} constrói uma função que conta o numero de ocorrências de uma palavra em um $String$.

\begin{lstlisting}[caption={Função $count$\protect\footref{fnt:prog-with-arrows}}, style=haskell-style, label={lst:func-count}]
count w = length . filter (==w) . words
\end{lstlisting}

A função $count$ é implementada pela união de $length$, $filter$, $==$ e $words$. Por último mas não menos importante, a função de composição $(.)$ atua na implementação de $count$ como um operador de ligação entre as funções menores. Entretanto, funções com efeitos colaterais não são compostas tão facilmente. 
Conforme a Listagem~\ref{lst:func-io}, $readFile$ retorna um $String$ encapsulado pela mónade $IO$. Em contrapartida, $count$ espera um $String$ como argumento, não um tipo construtor $m$.

\begin{lstlisting}[caption={Funções de E/S\protect\footref{fnt:prog-with-arrows}\protect\footref{fnt:prelude}}, style=haskell-style, label={lst:func-io}]
readFile :: FilePath -> IO String
\end{lstlisting}

Não há como por exemplo utilizar $(.)$ para unir $readFile$ e $count$, ou seja, não é possível ler um arquivo do disco e contar a ocorrência de uma determinada palavra. Entretanto, a união destas é desejável. Sendo assim, para permitir a composição destes tipos de funções, Hughes introduziu a type class $Arrow$. Na Listagem~\ref{lst:tc-arrow}, $Arrow$ denota uma computação pelos tipos $b$, $c$ e $d$, um tipo construtor $a$ e as operações $arr$ e $>>>$. 

\begin{lstlisting}[caption={Type class Arrow\protect\footref{fnt:arrow-user-interface}}, style=haskell-style, label={lst:tc-arrow}]
class Arrow a where
	arr   :: (b -> c) -> a b c
	(>>>) :: a b c -> a c d -> a b d
\end{lstlisting}

Destas, a mais comum é $arr$, declarada com a assinatura ${(b \rightarrow c) \rightarrow a\;b\;c}$. Dada qualquer função com entrada $b$ e saída $c$, $arr\;f$ constrói uma instância de $Arrow$ de $f$~\cite{courtney2001genuinely}. 

A segunda operação é definida simbolicamente por $(>>>)$ com assinatura ${a\;b\;c \rightarrow a\;c\;d \rightarrow a\;b\;d}$. Recebe como argumento uma instância definida por ${a\;c\;d}$ e retorna $a\;b\;d$. Logo, $>>>$ aplica sequencialmente as funções passadas para $arr$, gerando uma computação de entrada $b$ e saída $d$.

Por exemplo, $arr$ na instancia $(\rightarrow)$ da Listagem~\ref{lst:func-comp-arrow} é implementada pela função de identidade $id$. Já $(>>>)$ utiliza a composição de funções $(.)$ e a função $flip$~\cite{hughes2005programming}.

\begin{lstlisting}[caption={Arrow - Composição de Funções\protect\footref{fnt:prog-with-arrows}}, style=haskell-style, label={lst:func-comp-arrow}]
instance Arrow (->) where
	arr   = id
	(>>>) = flip (.)
\end{lstlisting}

Assim, define-se um tipo $Arrow\;(\rightarrow)$ capaz operar sob funções ordinárias do tipo $a \rightarrow b$, sendo $a$ e $b$ tipos quaisquer.

\addtocounter{footnote}{1}
\footnotetext{Fonte: J. Hughes, Programming with Arrows, p. 73--79, 2005.\label{fnt:prog-with-arrows}}

%Apesar de parecidas, type classes não são iguais à interfaces, presentes na %orientação a objetos. Type classes expressam sobrecarga de método (polimorfismo ad-%hoc) enquanto interfaces trabalham com instâncias de classes e sobrecarga por %subtipagem.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
